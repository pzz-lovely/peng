# 注解

注解本事不会任何事情。它们只是存在于源文件。编译器将它们置于类文件中，并且虚拟机会将 它们载入。

所有的注解接口隐式地扩展自java.lang.annotation.Annotation接口。

~~~java
			java.lang.reflect.AnnotatedElement interface
boolean isAnnotationPresent(Class<? extends Annotation> annotationType)
//如果该项具有给定类型的注解，则返回true

<T extends Annotation> T getAnnotation(Class<T> annotationType)
//获得给定类型的注解Annotation，如果该项不具有这样的注解，则返回null

<T extends Annotation> T[] getAnnotatiosByType(Class<T> annotationType)
//获得某个可重复注解类型的所有注解Annotation。或者返回长度为0的数组

Annotation[] getAnnotations()
//获得作用于该项的索引注解，包括继承而来的注解。如果没有出现任何注解，那么将返回一个长度为 0的数组
Annotation[] getDeclaredAnnotation()
//获得为该声明的所有注解，不包含继承而来的注解。如果没有任何注解返回 为 0的数组。

~~~



~~~java
			java.lang.annotation.Annotation
Class<? extends Annotation> annotationType()
//返回Class对象，它用于描述该注解对象的注解接口。注意: 调用注解对象上的getClass方法可以返回真正的类，而不是接口

~~~

## 通过反射获取Annotation信息

在Java里面反射机制可以实现类结构。

Java类结构![](D:\task\peng2\Swing2\src\main\resources\annotation\注解的类结构.png)

实线 是 继承 虚线 是 实现 

## 自定义Annotation

在定义Annotation的时候发现有一个属性的名称为value，则这个属性的内容可以直接编写，而不需要通过变量名称来记性定义

