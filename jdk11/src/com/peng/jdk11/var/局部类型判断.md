什么是局部类型推断？

~~~
var str = "helloworld";
System.out.println(str);
~~~

局部变量类型推断就是左边的类型直接使用var定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的str变量使用var定义，编译器就能通过右边的"helloworld"自动推断出这是一个String类型的变量。但是，值得注意的是，这个var并不是一个关键字，很多同学看到变量都能使用var来定义，那var还不是关键字吗？事实上，它真的不是一个关键字。

~~~
int var = 10;
System.out.println(var);
~~~

例如上面的这段代码是能够正确运行的，这证明var不是关键字。我们还可以通过反编译来看，例如我们反编译这样一段代码：

~~~
var a = 100;
System.out.println(a);
~~~

反编译得到的结果为：

~~~
byte a = 100;
System.out.println(a);
~~~

从这里可以看出，var仅仅是一个语法上的改进，在编译时期便已经将var转换为了对应的变量类型。然而在使用var定义变量时，必须立刻赋值，例如下面的情况是错误的：

~~~
var a;
~~~

因为在不赋值的情况下，JVM无法推断当前变量的类型。在类中的成员变量(也叫属性)不可以使用var来定义，例如下面的情况是错误的：

~~~
class Student{
    var name = "小明";
    var age = 20;
}
~~~

var的好处在lambda表达式中体现得淋漓尽致。我们知道，开启一个线程可以使用lambda表达式来完成：

~~~
Thread t = new Thread(() -> System.out.println(Thread.currentThread().getName()));
t.start();
~~~

这是一个无参的lambda表达式形式，我们再看一个带参lambda表达式：

~~~
String[] arr = { "program", "creek", "is", "a", "java", "site" };
Stream<String> stream = Stream.of(arr);
stream.forEach(x -> System.out.print(x + "\t"));
~~~

这是一个forEach的用法，其中需要用到变量x，因为这里它自动推断出了x的类型为String，所以String被省略了，那么加上var之后代码变成这样：
String[] arr = { "program", "creek", "is", "a", "java", "site" };
Stream<String> stream = Stream.of(arr);
stream.forEach((var x) -> System.out.print(x + "\t"));


如果仅仅只是这样写，倒是无法看出写var有什么优势，反而觉得有点多此一举，但是如果要给lambda表达式变量标注注解的话，那么这个时候var的作用就体现出来了。

~~~
String[] arr = { "program", "creek", "is", "a", "java", "site" };
Stream<String> stream = Stream.of(arr);
stream.forEach((@Nonnull var x) -> System.out.print(x + "\t"));
~~~

那么var的优势何在呢？因为你要标注注解的话，就必定要写出x的类型，如下面这段程序是错误的：

~~~
String[] arr = { "program", "creek", "is", "a", "java", "site" };
Stream<String> stream = Stream.of(arr);
stream.forEach((@Nonnull x) -> System.out.print(x + "\t"));
~~~

但是，我们从何得知x的类型呢？其实我们不用知晓，因为var就能自动推断，所以，var的好处在这里就体现出来了。
