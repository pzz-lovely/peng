    2.1volatile的应用
        在多线程并发编程中synchronized和volatile都扮演着重要的角色，volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的"可见性"。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。它比synchronized的使用和执行成本更低，因为他不会引起线程上下文的切换和调度。
        CPU的术语定义
        术语      英文单词            术语描述
        内存屏障    memory barriers   是一组处理器指令，用于实现对内存操作的顺序限制
        缓存行     cache line         cpu高速缓存中可以分配的最小存储单元。处理器填写缓存行时会加载整个缓存行，现代CPU需要执行几百次CPU指令
        原子操作    atomic operations  不可中断的一个或一系列操作
        缓存行填充   cache line fill    当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个高速缓存行到适当的缓存(L1,L2,L3的或所有)
        缓存命中    cache hit          如果进行高速缓存行填充操作的内存位置仍然是下一次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取
        写命中     write hit           当处理器将操作数写回到一个内存缓存的区域是，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中
        写缺失      write misses the cache     一个有效的缓存行被写入到不存在的内存区域
    2.2synchronized的实现原理与应用
        对于普通同步方法，锁是当前实例对象
        对于静态方同步方法，锁是当前类的Class对象
        对于同步方法块，锁是synchronized括号里配置的对象
        JVM基于进入和退出的Monitor对象来实现方法同步和代码同步。
            代码同步是使用monitorenter和monitorexit指令实现的
            方法同步是使用另一种方式实现的。
        monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束和异常处，JVM要保证每个monitorenter必须要有对应的monitorexit匹配。线程执行到monitorenter指令是，将会尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁

    2.2.1 java对象头
        无锁 25bit对象的HashCode 4bit分代年龄 1bit是否是偏向锁0 2bit锁标志位01
        偏向锁 23bit线程id 2bitEpoch偏向锁时间戳 4bit分代年龄 1bit是否偏向锁1 2bit锁标志位01
        轻量级锁 30bit指向栈中锁记录的指针 2bit锁标志位00
        重量级锁 30bit指向重量级锁的指针 2bit10
        GC标记 30bit空 2bit锁标记位11
    2.2.2 锁的升级与对比
        锁一共有4中状态: 无锁，偏向锁，轻量级锁，重量级锁
        偏向锁解决了:同一个线程获取到了锁，在获取锁会很容易
            偏向锁的撤销:偏向锁使用了一种等到竞争出现才出现释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。
                1.等待全局安全点(在这个时间点和是哪个没有正在执行的字节码)
                2.暂停拥有偏向锁的线程
                3.检查偏向锁的线程是否活着，如果持有偏向锁的线程活动着。
                4.活动着 拥有偏向锁的站会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word 要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁。
                4.没有活动 则将对象头设置为无锁状态
                5.唤醒暂停的线程
            关闭偏向锁: 通过JVM参数 -XX:-UseBiasedLocking=false,程序默认会进入轻量级锁状态

            轻量级锁加锁：
                1.线程在执行代码同步块之前JVM会先在当前线程的栈帧中创建用于存储锁记录的空间
                2.并将对象头中的Mark Word复制到锁记录中(官方称为Displaced Mark Word)
                3.线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针
                    3.5成功 当前线程 获取锁
                    3.5失败 表示其他线程也在竞争锁，当前线程便尝试使用自旋获取锁
            轻量级锁解锁:
                1.轻量级锁解锁时,会使用原子的CAS操作将Displaced Mark Word替换回到对象头
                2.成功 表示竞争没有发生
                2.失败 表示存在竞争，锁就会膨胀城重量级锁
            锁的优缺点:
                偏向锁
                    优点:加锁和解锁不需要额外的消耗，和执行非同步方法相比存在纳秒级的差距
                    缺点:如果线程间存在锁竞争，会带来额外的锁撤销的消耗
                    适用场景:只有一个线程访问同步块场景
                轻量级锁:
                    优点:竞争的线程不会阻塞，提高了程序的响应速度
                    缺点:如果始终得不到锁竞争的线程，使用自旋会消耗CPU
                    使用场景:追求响应时间同步块执行熟读非常快
                重量级锁:
                    优点:线程竞争不使用自旋，不会消耗CPU
                    缺点:线程阻塞，响应时间缓慢
                    适用场景:追求吞吐量同步块执行速度较长
    2.3 原子
        原子(atomic) 不能被进一步分割的最小粒子
        1.CPU术语
        缓存行 Cache line 缓存的最小操作单位
        比较并交换 Compare and Swap CAS操作需要输入两个数值，一个旧值(期望改变前的值)，和一个新值，在操作期间先比较就只有没有发生变化，如果没有发生变化，才交换新值，发生了变化则不交换
        CPU流水线 CPU pipeline CPU流水线的工作方式就像工业生产上的装配线，在CPU中有5~6个不同的功能电路单元组成一条处理流水线，然后将一条X86指令分成5~6布后再由这些电路单元分别执行，这样就能实现在一条CPU时钟周期完成一条指令，因此提高CPU的运算速度
        内存顺序冲突 Memory order violation 内存顺序冲突一般是由假共享引起的，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，而出现这个内存顺序冲突时，CPU必须清空流水线
        2.处理器处理原子操作
            32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理之间的原子操作。
            处理器会保证基本的内存操作的原子性
            但是复杂的内存操作处理器不能保原子性，比如跨总线宽度，夸多个缓存行和跨页表的访问。
            1.第一个机制通过总线锁保证原子性。
                原因:多处理器同时对共享变量进行读改写操作(i++),那么多个处理器同时进行操作。多个处理器同时从各自的缓存中读取变量i，分别进性i+1操作，然后分别写入系统内存中。想要保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。
                解决:总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。
            2.第二个机制是通过缓存锁定来保证原子性
                原因:总线开销大
                解决:频繁使用的内存会缓存在处理器的L1,L2,3的高速缓存里，那么原子操作就可以直接在处理器的内部缓存进行，并不需要声明总线锁。缓存锁定:是指内存区域如果被缓存在处理器的缓存行中，并且在LOCK操作期间被锁定，那么当它执行锁操作回写到内存是，处理不在总线上声言LOCK#信号，而是修改内部的内存，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性制止会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写以被锁定的缓存行的数据，会使缓存行无效，这是就得从内存中重新读取
        3.java实现原子操作
            1.使用循环CAS实现原子操作
               JVM中的CAS
                    JVM中的CAS操作正式利用了处理器提供的CMPXCHG指令实现的。
            ABA问题:
                版本号问题