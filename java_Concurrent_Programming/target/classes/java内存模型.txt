3.1.1 并发编程模型的两种
    1.共享内存: 线程之间共享程序中的公共状态，通过写 - 读内存中的公共状态进行隐式通信。同步是显示进行的
    2.消息传递: 线程模型中没有公共状态，线程之间必须通过发送消息来显示进行通信。同步是隐式进行的
    java并发采用的是共享内存
3.1.2 java内存模型的抽象结构 抽象
    在Java中，所有的实例域，静态域和数组元素[以上都称为"共享变量"]都存储在堆内存中，堆内存在线程之间共享。局部变量(Local Variables)，方法定义参数(Formal Method Parameters)和异常处理器参数(Exception Handler Parameters)不会在线程间共享，不受内存模型的影响。
    java线程之间的通信有java内存模型(JMM抽象的)控制。
    线程之间的共享变量存储在主内存(Main Memory)中
    每个线程都有一个现私有的本地内存(Local Thread),用来存储该线程 读/写 共享变量的副本。 本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化
    java线程之间的通信过程 线程A 线程B
        1.线程A把本地内存存储的数据 x = 1 通过JMM控制传到主内存中
        2.线程B把通过JMM控制把主内存更新过的值 传到 线程B的本地内存
3.1.3 指令的序列 的 排序
    编译器排序:(1)编译器重排序
        JMM的编译重排序规则会禁止特定类型的编译器重排序
    处理器排序:(2)指令级排序，(3)内存系统排序
        处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障(Memory Barriers)指令，通过内存屏障来禁止特定类型的处理器重排序
    编译器重排序,编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行的顺序
    指令级并行的重排序.现代处理器采用了指令级并行技术(Instruction-Level Parallelism,ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器
    内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储从操作看上去可能是在轮序执行
3.1.4 并发编程的模型
    现代的处理器使用写缓冲区临时保存箱内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据产生的延迟。同时通过批处理的方式刷新缓冲区，以及合并缓冲区对同一内存地址的多次写，减少对内存总线的占用。每个处理器所在的写缓冲区，仅仅只在它所在的处理器可见。
    处理器对内存 读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！
    LoadLoad Barriers Load1;LoadLoad;Load2 确保Load1数据的装载先于Load2及后续装载指令的装载
    StoreStore Barriers Store1;StoreStore;Store2 确保Store1数据对其他处理器可见(刷新到内存)先于Store2及所有后续存储指令的存储
    LoadStore Barriers Load1;LoadStore;Store2 确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存
    StoreLoad Barriers Store1;StoreLoad;Load2 确保Store1数据对其他处理器变得可见(指刷新到内存)先于load2及所有后续装载指令的装载。StoreLoad Barriers会是该屏障之前的所有内存访问指令(存储和装载指令)完成之后，才执行该屏障之后的内存访问指令
    StoreLoad Barriers是一个"全能型"的屏障，执行该屏障会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中(Buffer Fully Flush)
3.1.5 happens-before 发生 之前
    jdk开始，java使用新的JSR-133内存模型。JSR-133使用happens-before的概念来阐述操作之间的可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关闭
    happens-before规则如下:
        程序顺序规则:一个线程中的每个操作，happens-before与该线程中任意后续操作
        监视器锁规则:对一个锁的解锁，happens-before与随后对这个锁的加锁
        volatile变量规则:对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
        传递性:如果A happens-beforeB，且B happens-before C，那么A happens before C
        一个happens-before规则对应一个或多个编译器和处理器重排序规则。
3.2 重排序
    重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段
3.2.1 数据依赖性
    如果两个操作访问同一个变量，且这两个操作中有一个写操作，此时这两个操作之间就存在数据依赖性。
    写后读  a=1;b=a; 写一个变量之后，在读取这个变量的位置
    写后写 a=1;a=2;  写一个变量之后，再写这个变量
    读后写 a=b;b=1 先一个变量之后，再写这个变量
    编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数依赖关系的两个操作的执行顺序。
    数据依赖性仅针对单个处理器中执行的指令序列和单个线程执行的操作，不同操作之间和不同线程之间的数据依赖性不被编译器和处理器考虑
