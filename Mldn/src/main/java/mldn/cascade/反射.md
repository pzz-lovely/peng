# 反射

## 传统属性赋值

根据"一对字符串"实例java对象实例类，并赋值属性。如果有300万个类，那就会代码冗余。

## 属性自动赋值

给定当前属性的格式。属性名称和字符串结构存在相对应关系。

![image-20200321222756289](D:\task\peng2\src\main\java\mldn\Class方法赋值.png)



## 单级属性赋值

单级属性是指在当前给定的简单Java类之中没有其他类的对象引用，这样的设计成为单级关系，单级关系，只需要动态获取方法名称，而后再进行动态的对象创建操作即可

## 多级联对象实例

当前的类 中存在其他 对象的引用。级联关系的配置关系就是通过 属性.属性.属性 的形式进行描述处理的。









~~~java
//分隔
public interface FieldSplit{
    public static final String SPLIT_ALL = "\\|";
    public static final String SPLIT_FIELD = ":";
    public static final String SPLIT_FIELD_OBJ = "\\.";
    
    public static String[] splitALL(String value){
        return value.split(SPLIT_ALL);
    }
    public static String[] splitField(){
        return value.split(SPLIT_FIELD,2);
    }
    public static String[] splitFieldObj(String value){
        return value.split(SPLIT_FIELD_OBJ);
    }
}
public class StringUtil{
    public static String initCap(String value){
        if(value == null || "".equals(value))
            return null;
        if(value.length()==1)
            return value.toUpperCase();
        return value.substring(0,1).toUpperCase()+value.substring(1);
    }
}
/*name:0.0|job:aa|age:12|birthday:2019-10-12 12:02:34|
dept.deptNo:20|dept.deptName:教学|
dept.company.cno:1|dept.company.cname:嗷嗷*/
//创建对象 并且给对象赋值
public class BeanUtil{
    private static final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    private static final ZoneId zoneId = ZoneId.systemDefault();

    public static void setObjectValue(Object obj,String value){
        String content[] = FieldSplit.splitALL(value);
        for(int i = 0 ; i < content.length ;i++){
            try {
                //获取field 的 属性名[0] 属性值[1];
                String[] fieldNameAndValue = FieldSplit.splitField(content[i]);
                //有.代表 多级联引用
                if (fieldNameAndValue[0].contains(".")) {
                    String[] fieldObjName = FieldSplit.splitFieldObj(fieldNameAndValue[0]);
                    //这里返回的下一个级联的 对象。
                    Object fieldObj = setFieldObject(obj, fieldObjName);
                    setFieldValue(fieldObj, fieldObjName[fieldObjName.length - 1], fieldNameAndValue[1]);
                } else {	//没有直接赋值
                    setFieldValue(obj, fieldNameAndValue[0], fieldNameAndValue[1]);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    //为级联对象中的属性 赋值 返回的还是这个obj对象
    public static Object setFieldObject(Object obj,String[] fieldObjName) throws Exception {
        //dept.company.cno
        for(int i = 0 ; i < fieldObjName.length-1;i++){
            Method method = obj.getClass().getMethod("get"+StringUtil.initCap(fieldObjName[i]));
            Object fieldObj= method.invoke(obj);
            //检测多级联 中的 属性对象是否 为空
            if(fieldObj==null){
                //获取 属性
                Field field = obj.getClass().getDeclaredField(fieldObjName[i]);
                fieldObj = field.getType().getConstructor().newInstance();
                //为当前 这个级联对象 的属性赋值
                Method setMethod =  obj.getClass().getDeclaredMethod("set"+StringUtil.initCap(fieldObjName[i]),
                        field.getType());
                setMethod.invoke(obj,fieldObj);	//将下一级联对象 引用
                //因为当前级联对象属性 保存这个 下一个级联对象的引用。所以 fieldObj修改的值会 返回到 上一个级联引用里面。
                obj = fieldObj;  //替换引用
            }else{
                obj = fieldObj;	//可能下一级联的对象中，也有下一个级联对象
            }
        }
        return obj;
    }


    //为对象的属性赋值
    public static void setFieldValue(Object obj,String fieldName,String fieldValue)throws Exception{
        Field field = obj.getClass().getDeclaredField(fieldName);
        Method method = obj.getClass().getMethod("set"+StringUtil.initCap(fieldName),field.getType());
        method.invoke(obj,convert(field.getType().getName(),fieldValue));
    }
    //类型转换
    private static Object convert(String typeName,String value){
        try{
            switch(typeName){
                case "java.lang.String":
                    return value;
                case "java.lang.Integer":
                    return Integer.parseInt(value);
                case "java.lang.Double":
                    return Double.parseDouble(value);
                case "java.lang.Long":
                    return Long.parseLong(value);
                case "java.math.BigDecimal":
                    return new BigDecimal(value);
                case "java.util.Date":
                    LocalDateTime localDateTime = LocalDateTime.parse(value,dateTimeFormatter);
                    Instant instant = localDateTime.atZone(zoneId).toInstant();
                    return Date.from(instant);
            }
        }catch(Exception e){}	//可能会出现强转异常
        return null;
    }

}
//获取到对象 实例化
public class ObejctInstanceFactory{
    public static <T> T create(Class<T> clazz,String value){
        /*
            * Object obj = new Employee(); 当前是这个Employee引用
            * 但是
            * obj = new Dept();  变成了Dept的引用了。
            * */
        Object obj = clazz.getDeclaredConstructor().newInstance();	
        BeanUtil.setObjectValue(obj,value);
        return (T)obj;
    }
}
~~~

