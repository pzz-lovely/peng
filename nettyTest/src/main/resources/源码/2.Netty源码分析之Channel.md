## Channel系列类结构

Netty中的io.netty.channel 对应着 通信中所需要的 服务器或客户端封装。

一个Channel对应着一个ChannelPipeline。

![](../images/ChannelHandlerContext....png)

## AbstractChannel

## 继承体系

![](../images/%E6%BA%90%E7%A0%81/AbstractChannel.png)

* ChannelOutboundInvoker定义了、绑定，连接，入站，出站等事件
* Channel，定义了当前Channel的一个配置，如：提供当前状态（是否能 读，写），通道配置参数eventLoop，有一个 父通道，这取决于它是如何创建的，所支持的IO操作都是异步的（像极了java.util
.concurrent.Future类，I/O调用会立即返回，而不能保证I/O操作是否以及完成，会返回ChannelFuture这会在操作结束后自动通知你）。

## Channel家族成员

Netty 还支持非常多的通讯连接协议，每种协议还有 NIO(异步 IO) 和 OIO(Old-IO， 即传统的阻塞 IO) 版本的区别。对应于不同协议，都有不同的 Channel 类型与之对应。

下面是一些常用的 Channel 类型:

NioSocketChannel： 代表异步的客户端 TCP Socket 连接.

NioServerSocketChannel： 异步的服务器端 TCP Socket 连接.

NioDatagramChannel： 异步的 UDP 连接

NioSctpChannel： 异步的客户端 Sctp 连接.

NioSctpServerChannel： 异步的 Sctp 服务器端连接.

OioSocketChannel： 同步的客户端 TCP Socket 连接.

OioServerSocketChannel： 同步的服务器端 TCP Socket 连接.

OioDatagramChannel： 同步的 UDP 连接

OioSctpChannel： 同步的 Sctp 服务器端连接.

OioSctpServerChannel： 同步的客户端 TCP Socket 连接.

### AbstractNioChannel和本地Channel的关系

![](../images/%E6%BA%90%E7%A0%81/AbstractNioChannel%E4%BE%9D%E8%B5%96.png)

AbstractNioChannel中依赖了一个SelectableChannel类。

SelectableChannel它定义的阻塞的方式。

#### 属性

~~~java
// 阻塞Channel
private final SelectableChannel ch;

protected final int readInterestOp;
// 选择事件
volatile SelectionKey selectionKey;
boolean readPending;
private final Runnable clearReadPendingRunnable = new Runnable() {
    @Override
    public void run() {
        clearReadPending0();
 	}
};

private ChannelPromise connectPromise;
private ScheduledFuture<?> connectTimeoutFuture;
// 请求远程地址
private SocketAddress requestedRemoteAddress;
~~~

#### 构造方法

~~~java
	protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
        super(parent);
        // 初始化 阻塞Channel
        this.ch = ch;
        this.readInterestOp = readInterestOp;
        try {
            // 设置为非阻塞
            ch.configureBlocking(false);
        } catch (IOException e) {
            try {
                ch.close();
            } catch (IOException e2) {
                logger.warn("Failed to close a partially initialized socket.", e2);
            }

            throw new ChannelException("Failed to enter non-blocking mode.", e);
        }
    }
~~~

