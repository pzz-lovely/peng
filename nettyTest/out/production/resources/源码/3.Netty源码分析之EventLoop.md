## 初始化EventLoop

EventLoop是Netty最基础的类。学习EventLoop的原理，是研究和学习Netty架构的亲体。

EventLoop 不是Netty中的一个类，而是一系列的类，或者说一组类。这一组类的作用，对应于Reactor模式的Reactor 角色。

## Reactor模式

channel和selector属于java.nio包中的类，分别为网络通信中的通道（连接）和选择器。

Reactor和handler属于Reactor模式高性能编程中的应用程序角色，分别反应器和处理器。

### Reactor模式的三部曲

Reactor模式可以被清醒的分成三大步：注册、轮询、分发。

1. 注册

将channel通道的就绪事件，注册到选择器Selector。一般来说，一个Reactor对应一个选择器Selector，一个Reactor拥有一个Selector成员属性。

2. 轮询

轮询的代码，是Reactor重要的一个组成部分，或者说核心的部分。轮询选择器是否有就绪事件

3. 分发

将就绪事件，分发到事件附件的处理器handler中，有handler完成实际的处理。

### Netty在Reactor模式应用

Netty中的Channel系列类型，对应于经典Reactor模型中的client，封装了用户的通讯连接。

Netty中的EventLoop系列类型，对应于经典Reactor模型中的Reactor，完成Channl的注册、轮询、分发。

Netty中的Handler系列类型，对应于经典Reactor模型中的Handler，不过Netty中的Handler设计的更加的高级和巧妙，使用了pipeline模式。

### NioEventLoop

Netty中的NioEventLoop类，就是对应非阻塞IO chnange的Reactor 反应器。

NioEventLoop类型绑定了两个重要的java本地类型，一个Selector类型，一个Thread类型。

本地Selector属性的作用，用于注册Java本地channel。本地线程属性的作用，主要用于轮询。

![](../images/%E6%BA%90%E7%A0%81/NioEventLoop%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%EF%BC%882%EF%BC%89.png)

~~~java
public final class NioEventLoop extends SingleThreadEventLoop {



/**
 * The NIO {@link java.nio.channels.Selector}.
 */
Selector selector;
private SelectedSelectionKeySet selectedKeys;
private final SelectorProvider provider;

private final SelectableChannel ch;
protected final int readInterestOp;
volatile SelectionKey selectionKey;


}

// 在父类SingleThreadEventExecutor中，定义了一个线程属性thread
public abstract class SingleThreadEventExecutor {

private final Thread thread;
private final ThreadProperties threadProperties;


}
~~~

Netty中，一个EventLoop，可以注册很多不同的Netty Channel。相当于是一对多的关系。

这一点，和Java NIO中Selector和channel的关系，也是一致的。

## 注册

在Java NIO，第一步首先是channel到selector的事件就绪状态的注册。Netty，也是类似的、

在此之前，Netty有一些启动的工作需要完成。这些启动的工作，包含了EventLoop、Channel的创建。 这块BootStrap 的启动类和系列启动工作，后面有文章专门介绍。下面假定启动工作已经完成和就绪，开始进行管道的注册。

![](../images/%E6%BA%90%E7%A0%81/Channel%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.png)

~~~java
// AbstractBootstrap.initAndRegister()
final ChannelFuture initAndRegister() {
    Channel channel = null;
    try {
        // 获取channel
        channel = channelFactory.newChannel();
        // 初始化channel
        init(channel);
    } catch (Throwable t) {
        if (channel != null) {
            channel.unsafe().closeForcibly();
            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
        }
        
        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
    }
    // MultithreadLoopGroup.register() 注册Channel
    ChannelFuture regFuture = config().group().register(channel);
    if (regFuture.cause() != null) {
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }
    return regFuture;
}

// MultithreadEventLoopGroup.register
@Override
public ChannelFuture register(Channel channel) {    
    // EventExecutorChooserFactory.EventExecutorChooser chooser.register()
    // 
    return next().register(channel);
}

// SingleThreadEventLoop.register
public ChannelFuture register(Channel channel) {
    return register(new DefaultChannelPromise(channel, this));
}

@Override
public ChannelFuture register(final ChannelPromise promise) {
    ObjectUtil.checkNotNull(promise, "promise");
    // 注册
    promise.channel().unsafe().register(this, promise);
    return promise;
}

// AbstractChannel.AbstractUnsafe.register
@Override
public final void register(EventLoop eventLoop, final ChannelPromise promise) {
	ObjectUtil.checkNotNull(eventLoop, "eventLoop");
    // 是否被注册过
    if (isRegistered()) {
    	promise.setFailure(new IllegalStateException("registered to an event loop already"));
        	return;
    }
    // 是否兼容 eventLoop
    if (!isCompatible(eventLoop)) {
        promise.setFailure(new IllegalStateException("incompatible event loop type: " + eventLoop.getClass().getName()));
            return;
        }
        // AbstractChannel属性中eventLoop赋值
        AbstractChannel.this.eventLoop = eventLoop;
        
        // 是否以在 事件循环
        if (eventLoop.inEventLoop()) {
        	register0(promise);
        } else {
            try {
            	eventLoop.execute(new Runnable() {
                	@Override
                    public void run() {
                    	register0(promise);
                    }
                });
            } catch (Throwable t) {
                logger.warn("Force-closing a channel whose registration task was not accepted by an event loop: {}",AbstractChannel.this, t);
                closeForcibly();
                closeFuture.setClosed();
                safeSetFailure(promise, t);
            }
        }
   }
}

// AbstractNioChannel.register0
private void register0(ChannelPromise promise) {
    try {
        if (!promise.setUncancellable() || !ensureOpen(promise)) {
            return;
        }
        boolean firstRegistration = neverRegistered;
        // 真正的Channel 注册
        doRegister();
        neverRegistered = false;
        registered = true;


        pipeline.invokeHandlerAddedIfNeeded();

        safeSetSuccess(promise);
        // 调用 Channel 注册
        pipeline.fireChannelRegistered();
        // 是否处于活动状态
        if (isActive()) {
            if (firstRegistration) {
                pipeline.fireChannelActive();
            } else if (config().isAutoRead()) {

                beginRead();
            }
        }
    } catch (Throwable t) {
        closeForcibly();
        closeFuture.setClosed();
        safeSetFailure(promise, t);
    }
}

// AbstractEventLoop.doRegister()
@Override
protected void doRegister() throws Exception {
    boolean selected = false;
    // selectableChannel注册selector，并将AbstractBootstrap作为附加对象
    for (;;) {
        try {
            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
            return;
        } catch (CancelledKeyException e) {
            if (!selected) {
         
                eventLoop().selectNow();
                selected = true;
            } else {
                throw e;
            }
        }
    }
}
~~~

AbstractNioChannel属性中有一个SelectableChannel ch属性

在AbstractChannel.AbstractUnsafe 中初始化 eventLoop = eventLoop，说明每个Channel都会关联一个特定的EventLoop

最后异步，在关联好Channel和EventLoop后，会继续调用底层的Java Nio SocketChannel 的register，将底层的 Java NIO SocketChannel 注册到指定的 selector 中。

### 轮询

EventLoop作为Reactor反应器的角色，是Reactor模式的核心，EventLoop就会开启轮询模式。

在上面代码中 AbstractChannel.AbstractUnsafe.register中，有个eventLoop.execute()方法调用，这个调用，就是启动EventLoop的本地线程的入口。

~~~java
if(eventLoop.execute(()-> {
    register0(promise);
}))
~~~

在execute方法中，会调用startThread()，启动线程。

~~~java
// SingleThreadEventExecutor
@Override
public void execute(Runnable task) {
    ObjectUtil.checkNotNull(task, "task");
    execute(task, !(task instanceof LazyRunnable) && wakesUpForTask(task));
}

// SingleThreadEventExecutor
private void execute(Runnable task, boolean immediate) {
    boolean inEventLoop = inEventLoop();
    // 将事件Channel注册 的任务 放进队列中
    addTask(task);
    // 是否在 EventLoop
    if (!inEventLoop) {
        // 调用startThread 方法，启动EventLoop线程，但是此时还没有注册Selector
        startThread();
        if (isShutdown()) {
            boolean reject = false;
            try {
                if (removeTask(task)) {
                    reject = true;
                }
            } catch (UnsupportedOperationException e) {
                    // The task queue does not support removal so the best thing we can do is to just move on and
                    // hope we will be able to pick-up the task before its completely terminated.
                    // In worst case we will log on termination.
            }
            if (reject) {
                reject();
            }
        }
    }

    if (!addTaskWakesUp && immediate) {
        wakeup(inEventLoop);
    }
}

// SingleThreadEventExecutor
public boolean inEventLoop(){
    return Thread.currentThread() = this.thread;
}
~~~

### EventLoop线程启动

在NioEventLoop的父类SingleThreadEvenExecutor中，有一个Thread类型属性。

在eventLoop.execute()方法调用，启动EventLoop的本地线程的入口。

~~~java
// AbstractUnsafe.register()
eventLoop.execute(new Runnable() {
	@Override
    public void run() {
    	register0(promise);
    }
});
~~~

#### 事件轮询

~~~java
// NioEventLoop
@Override
protected void run() {
    int selectCnt = 0;
    // 自旋
    for (;;) {
        try {
            /*
             * SELECT  -1   阻塞等待 IO事件
             * CONTINUE -2  重试循环 IO事件
             * BUSY_WAIT -3 轮询     IO事件
             *
             */
            int strategy;
            try {
                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());
                switch (strategy) {
                    case SelectStrategy.CONTINUE:
                        continue;
                    case SelectStrategy.BUSY_WAIT:
                        // fall-through to SELECT since the busy-wait is not supported with NIO
                    case SelectStrategy.SELECT:
                        long curDeadlineNanos = nextScheduledTaskDeadlineNanos();
                        if (curDeadlineNanos == -1L) {
                            // NONE = Integer.MAX_VALUE
                            curDeadlineNanos = NONE; // nothing on the calendar
                        }
                        // 设置阻塞的时间
                        nextWakeupNanos.set(curDeadlineNanos);
                        try {
                            // 有任务 就进行阻塞
                            if (!hasTasks()) {
                                strategy = select(curDeadlineNanos);
                            }
                        } finally {
                            // This update is just to help block unnecessary selector wakeups
                            // so use of lazySet is ok (no race condition)
                            nextWakeupNanos.lazySet(AWAKE);
                        }
                    default:
                    }
                } catch (IOException e) {
                    // If we receive an IOException here its because the Selector is messed up. Let's rebuild
                    // the selector and retry. https://github.com/netty/netty/issues/8566
                    rebuildSelector0();
                    selectCnt = 0;
                    handleLoopException(e);
                    continue;
                }
                // 选择器 加 1 估计这是有 连接了
                selectCnt++;
                cancelledKeys = 0;
                needsToSelectAgain = false;
                // io 比率 
                final int ioRatio = this.ioRatio;
                boolean ranTasks;
                if (ioRatio == 100) {
                    try {
                        if (strategy > 0) {
                            processSelectedKeys();
                        }
                    } finally {
                        // Ensure we always run tasks.
                        ranTasks = runAllTasks();
                    }
                } else if (strategy > 0) {
                    final long ioStartTime = System.nanoTime();
                    try {  
                        // 处理 SelectedKey
                        processSelectedKeys();
                    } finally {
                        // Ensure we always run tasks.
                        final long ioTime = System.nanoTime() - ioStartTime;
                        ranTasks = runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                    }
                } else {
                    ranTasks = runAllTasks(0); // This will run the minimum number of tasks
                }

                if (ranTasks || strategy > 0) {
                    if (selectCnt > MIN_PREMATURE_SELECTOR_RETURNS && logger.isDebugEnabled()) {
                        logger.debug("Selector.select() returned prematurely {} times in a row for Selector {}.",
                                selectCnt - 1, selector);
                    }
                    selectCnt = 0;
                } else if (unexpectedSelectorWakeup(selectCnt)) { // Unexpected wakeup (unusual case)
                    selectCnt = 0;
                }
            } catch (CancelledKeyException e) {
                // Harmless exception - log anyway
                if (logger.isDebugEnabled()) {
                    logger.debug(CancelledKeyException.class.getSimpleName() + " raised by a Selector {} - JDK bug?",
                            selector, e);
                }
            } catch (Throwable t) {
                handleLoopException(t);
            }
            // Always handle shutdown even if the loop processing threw an exception.
            try {
                if (isShuttingDown()) {
                    closeAll();
                    if (confirmShutdown()) {
                        return;
                    }
                }
            } catch (Throwable t) {
                handleLoopException(t);
            }
        }
    }

// NioEventLoop
private void processSelectedKeysOptimized() {
    // 遍历key 
    for (int i = 0; i < selectedKeys.size; ++i) {
        final SelectionKey k = selectedKeys.keys[i];
        // null out entry in the array to allow to have it GC'ed once the Channel close
        // See https://github.com/netty/netty/issues/2363
        selectedKeys.keys[i] = null;
    

        // 获取AbstractChannel
        final Object a = k.attachment();

        if (a instanceof AbstractNioChannel) {
            processSelectedKey(k, (AbstractNioChannel) a);
        } else {
            @SuppressWarnings("unchecked")
            NioTask<SelectableChannel> task = (NioTask<SelectableChannel>) a;
            processSelectedKey(k, task);
        }

        if (needsToSelectAgain) {
            // null out entries in the array to allow to have it GC'ed once the Channel close
            // See https://github.com/netty/netty/issues/2363
            selectedKeys.reset(i + 1);

            selectAgain();
            i = -1;
        }
    }
}

// NioEventLoop
private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
    // 注册Key
    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
    if (!k.isValid()) {
        final EventLoop eventLoop;
        try {
            eventLoop = ch.eventLoop();
        } catch (Throwable ignored) {
                return;
        }
        if (eventLoop == this) {
            // close the channel if the key is not valid anymore
            unsafe.close(unsafe.voidPromise());
        }
        return;
        }

    try {
        // 
        int readyOps = k.readyOps();
        if ((readyOps & SelectionKey.OP_CONNECT) != 0) {
            // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking
            // See https://github.com/netty/netty/issues/924
            int ops = k.interestOps();
            ops &= ~SelectionKey.OP_CONNECT;
            k.interestOps(ops);
            // Nio 调用read() write() 需要调用finishConnect()
            unsafe.finishConnect();
        }

        // Process OP_WRITE first as we may be able to write some queued buffers and so free memory.
        if ((readyOps & SelectionKey.OP_WRITE) != 0) {
            // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write
            ch.unsafe().forceFlush();
        }

        // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead
        // to a spin loop
        if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
                unsafe.read();
        }
    } catch (CancelledKeyException ignored) {
        unsafe.close(unsafe.voidPromise());
    }
}
~~~

### 分发任务

~~~java
AbstractNioChannel.read() 中的 pipeline.fireChannelRead(byteBuf)
~~~