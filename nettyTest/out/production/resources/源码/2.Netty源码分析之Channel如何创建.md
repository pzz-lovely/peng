## 问题

服务器的socket是在哪里初始化？

在哪里进行accept()连接？

## 步骤

### 初始化服务器

1. ServerBootstrap.bind() 用户代码入口

2. ServerBootstrap.initAndRegister() 初始化并注册Channel

3. ChannelFactory.newChannel() 创建服务端Channel

### 服务器创建
    1
我这里使用的是NioServerSocketChannel.class

~~~java
final ChannelFuture initAndRegister() {
    Channel channel = null;
    try {
        // 获取channel
        channel = channelFactory.newChannel();
        init(channel);
    } catch (Throwable t) {
        if (channel != null) {
            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
        }
        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
    }

    ChannelFuture regFuture = config().group().register(channel);
    if (regFuture.cause() != null) {
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }

    return regFuture;
}

// RefletiveChannelFactory
@Override
public T newChannel() {
    try {
        return constructor.newInstance();
    } catch (Throwable t) {
        throw new ChannelException("Unable to create Channel from class " + constructor.getDeclaringClass(), t);
    }
}

// NioServerSocketChannel
public NioServerSocketChannel() {
    this(newSocket(DEFAULT_SELECTOR_PROVIDER));
}

private static ServerSocketChannel newSocket(SelectorProvider provider) {
    try {
        // 调用jdk底层 获取ServerSocketChannel
        return provider.openServerSocketChannel();
    } catch (IOException e) {
        throw new ChannelException("Failed to open a server socket.", e);
    }
}

public NioServerSocketChannel(ServerSocketChannel channel) {
    // AbstractNioChannel
    super(null, channel, SelectionKey.OP_ACCEPT);
    // tcp配置参数
    config = new NioServerSocketChannelConfig(this, javaChannel().socket());
}
~~~

上面代码，调用父类的构造方法，将ServerSocketChannel传给父类AbstractNioMessageChannel再传给AbstractNioChannel。

AbstractNioChannel属性

~~~java
// SelectableChannel它定义的阻塞的方式。
private final SelectableChannel ch;
// 连接事件 OP_ACCEPT
volatile SelectionKey selectionKey;
~~~

ServerSocketChannel的创建。

~~~java
// AbstractNioChannel
protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
    super(parent);
    // 赋值
    this.ch = ch;
    // 设置channel的ops为SelectKey.OP_ACCEPT（值为16）
    this.readInterestOp = readInterestOp;
    try {
        // 设置为非阻塞模式
        ch.configureBlocking(false);
    } catch (IOException e) {
        try {
            ch.close();
        } catch (IOException e2) {
            logger.warn("Failed to close a partially initialized socket.", e2);
            }
        throw new ChannelException("Failed to enter non-blocking mode.", e);
    }
}

// AbstractChannel 对channel的抽象
protected AbstractChannel(Channel parent) {
    this.parent = parent;
    // 唯一标识
    id = newId();
    // tcp相关读写，底层操作。newUnsafe()是由子类AbstractNioMessageChannel实现的，里面实例化一个内部类（注：该类很重要，里面定义了read方法，会触发accept的调用，）
    unsafe = newUnsafe();
    // 根服务端和客户端的处理链
    pipeline = newChannelPipeline();
}

// DefaultChannelPipeline
// DefaultChannelPipeline维护了一个以DefaultChannelHandlerContext为元素的双向链表结构，Head是一个Outbound处理器，而tail是一个Inbound处理器。管道中的处理器链为：Head -> tail
protected DefaultChannelPipeline(Channel channel) {
    this.channel = ObjectUtil.checkNotNull(channel, "channel");
    succeededFuture = new SucceededChannelFuture(channel, null);
    voidPromise =  new VoidChannelPromise(channel, true);

    tail = new TailContext(this);
    head = new HeadContext(this);

    head.next = tail;
    tail.prev = head;
}
~~~

## Channel创建总结

1. 通过反射创建Channel类，通过newSocket()创建底层的JDK Channel，再创建ChannelConfig用来处理TCP参数配置类。

2. 将Channel传给AbstractNioChannel，并设置为非阻塞。

## 初始化Channel

1. init() 初始化入口

    1. set ChannelOptions,ChannelAttrs

    2. set ChildOptions,ChildAttrs。是为服务器创建新连接而创建的。

    3. config handler 配置服务端pipeline
    
    4. add ServerBootstrapAcceptor 添加连接器

~~~java
// ServerBootstrap
void init(Channel channel) {
    // 初始化 用户自定的 option
    setChannelOptions(channel, newOptionsArray(), logger);
    // 初始化 用户自定的 attr
    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));
    
    // pipeline是在 AbstractChannel创建的时候 初始化
    ChannelPipeline p = channel.pipeline();
    
    final EventLoopGroup currentChildGroup = childGroup;
    final ChannelHandler currentChildHandler = childHandler;
    final Entry<ChannelOption<?>, Object>[] currentChildOptions;
    synchronized (childOptions) {
        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);
    }
    final Entry<AttributeKey<?>, Object>[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);
    
    // 
    p.addLast(new ChannelInitializer<Channel>() {
        @Override
           public void initChannel(final Channel ch) {
            final ChannelPipeline pipeline = ch.pipeline();
            // 自己传入的 handler(Handler) 
            ChannelHandler handler = config.handler();
            if (handler != null) {
                pipeline.addLast(handler);
            }
            
            // 添加默认的ChannelHandler
            ch.eventLoop().execute(new Runnable() {
                @Override
                public void run() {
                    pipeline.addLast(new ServerBootstrapAcceptor(
                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                }
            });
        }
    });
}

~~~

上面方法主要做了两件事：

1. 设置NioServerSocketChannel的options和attrs，并存储之后用于SocketChannel的options和attrs.

2. 为NioSocketChannel对应的管道增加一个Inbound处理器ChannelInitializer。经过此步骤后，管道中的处理器链表为：head(outbound) -> ChannelInitializer(inbound) -> tail(inbound)。注意ChannelInitializer的实现方法initChannel，里面会当channelRegistered事件发生时将ServerBootstrapAcceptor加入到管道中


## 端口绑定

1. AbstractUnsafe.bind() 入口
    
    1.doBind()
    
        1. javaChannel().bind() jdk底层绑定
        
    2. pipeline.fireChannelActive() 传播事件
    
        1. HeadContext.readIfIsAutoRead() 将之前注册到select事件上，重新绑定为ACCEPT事件。这样有新连接事件，selector就会轮询到accept事件，最终就可以将这个连接给Netty处理。

~~~java
// AbstractChannel
// 此方法主要做两个事，一是调用底层 ServerSocketChannel绑定端口。二，触发ChannelActive事件
@Override
public final void bind(final SocketAddress localAddress, final ChannelPromise promise) {
    assertEventLoop();

    // ... 上面忽略
        
    // 端口绑定之前是false
    boolean wasActive = isActive();
    try {
        doBind(localAddress);
    } catch (Throwable t) {
        safeSetFailure(promise, t);
        closeIfClosed();
        return;
    }

    if (!wasActive && isActive()) {
        invokeLater(new Runnable() {
            @Override
            public void run() {
                // 触发channelActive事件
                pipeline.fireChannelActive();
            }
        });
    }

    safeSetSuccess(promise);
}

// AbstractBootstrap
private ChannelFuture doBind(final SocketAddress localAddress) {
    final ChannelFuture regFuture = initAndRegister();
    final Channel channel = regFuture.channel();
    if (regFuture.cause() != null) {
        return regFuture;
    }
    if (regFuture.isDone()) {
        // 到这一步 说明注册成功了
        ChannelPromise promise = channel.newPromise();
        doBind0(regFuture, channel, localAddress, promise);
        return promise;
    } else {
        // Registration future is almost always fulfilled already, but just in case it's not.
        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
        regFuture.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                Throwable cause = future.cause();
                if (cause != null) {
                // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
                // IllegalStateException once we try to access the EventLoop of the Channel.
                    promise.setFailure(cause);
                } else {
                    // Registration was successful, so set the correct executor to use.
                    // See https://github.com/netty/netty/issues/2586
                    promise.registered();

                    doBind0(regFuture, channel, localAddress, promise);
                }
            }
        });
        return promise;
    }
}

// 注册成功，就会调用这个方法
private static void doBind0(
    final ChannelFuture regFuture, final Channel channel,
    final SocketAddress localAddress, final ChannelPromise promise) {

    // This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up
    // the pipeline in its channelRegistered() implementation.
    channel.eventLoop().execute(new Runnable() {
        @Override
        public void run() {
            if (regFuture.isSuccess()) {
                // AbstractChannel.bind 绑定
                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
            } else {
                promise.setFailure(regFuture.cause());
            }
        }
    });
}

// NioServerSocketChannel
@Override
protected void doBind(SocketAddress localAddress) throws Exception {
    if (PlatformDependent.javaVersion() >= 7) {
        // 真正jdk socket 底层绑定 端口
        javaChannel().bind(localAddress, config.getBacklog());
    } else {
        javaChannel().socket().bind(localAddress, config.getBacklog());
    }
}

// DefaultChannelPipeline.HeadContext
@Override
public void channelActive(ChannelHandlerContext ctx) {
    ctx.fireChannelActive();

    readIfIsAutoRead();
}

// DefaultChannelPipeline.HeadContext
private void readIfIsAutoRead() {
    if (channel.config().isAutoRead()) {
        // 触发Channel读取
        channel.read();
    }
}
~~~
