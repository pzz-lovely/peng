# 并发容器

## 并发容器概览

- ConcurrentHashMap：线程安全的HashMap
- CopyOnWriteArrayList：线程安全的List
- BlockingQueue：这是一个接口，表示阻塞队列，非常适用于作为数据共享的通道
- ConcurrentLinkedQueue：高效的非阻塞并发队列，使用链表实现。可以看作一个线程安全的LinkedList
- ConcurrentSkipListMap：是一个Map，使用跳表的数据结构进行快速查找

## 集合类的历史--古老和过时的同步容器

Vector 和 Hashtable

ArrayList和Verctor：虽然这两个类不是线程安全的，但是可以用Collections.synchronziedList(new ArrayList\<E>())和Collections.synchronizedMap(new HashMap<K,V>())使之变成线程安全的

## ConcurrentHashMap

### Map简介

- HashMap
- Hashtable
- LinkedHashMap
- TreeMap

![](D:%5Ctask%5Cpeng_imooc%5Cjuc%5Csrc%5Cmain%5Cresources%5Cimages%5CMap%E6%8E%A5%E5%8F%A31.png)

### 为什么HashMap是线程不安全的

- 同时Put<b style='color:red'>碰撞</b>导致数据丢失
- 同时Put<b style='color:red'>扩容</b>导致数据丢失
- <b style='color:red'>死循环造成的CPU100%</b>：在多个线程核心扩容的时候，会造成链表的死循环。也就是你指向我，我指向你 

### HashMap分析

##### 红黑树

- 对二叉树BST的一种平和策略,O(longN) vs O(n) n可以看做容器的和长度。
- 会自动平衡，防止极端不平衡从而影响查找效率的情况发生。
- 每个节点要么是<b style="color:red">红色</b>，要么是<b style="color:red">黑色</b>，但根节点永远是<b style="color:red">黑色</b>的。
- <b style="color:red">红色节点不能连续</b>(也即是，红色节点的孩子和父亲都不能是红色)
- 从任一节点到其子树中每个叶子节点的路径都包含<b style="color:red">相同数量的黑色</b>节点
- 所有的叶节点都是 <b style="color:red">黑色</b>的

左边黑色节点 要比右边红色的 节点要小，而红色的节点 的右边 黑色节点 要小。

![](D:%5Ctask%5Cpeng_imooc%5Cjuc%5Csrc%5Cmain%5Cresources%5Cimages%5C%E7%BA%A2%E9%BB%91%E6%A0%91.png)

#### HashMap关于并发的特点

1. 非线程安全
2. 迭代时不允许修改内容
3. 只读的并发是安全的
4. 如果一定要把HashMap用在并发环境，用Collections.synchronziedMap(new HashMap())

### ConcurrentHashMap实现和分析

- Java7中的ConcurrentHashMap最外层是多个segement，每个segment的底层数据结构与HashMap类似，仍然是数组和链表组成的拉链法
- 每个segment<b style="color:red">独立上ReentrantLock锁</b>，每个segement之间互不影响，提高了并发效率
- ConcurreentHashMap默认有16个Segements，所有最多可以同时支持16个线程并发写。这个默认值可以在初始化的时候设置为其他值，但是一旦初始化以后，是不可以扩容的

##### Java8的Concurrent HashMap实现和分析

简介：采用Node，另外采用线程安全的方式 变成了cas 和synchronized

![](D:%5Ctask%5Cpeng_imooc%5Cjuc%5Csrc%5Cmain%5Cresources%5Cimages%5CHashMap%E5%88%86%E6%9E%90%201.8%202.png)

#### putVal流程

1. 判断key value 不为空
2. 计算hash值 
3. 根据对应位置节点的类型，来赋值，或者helpt Transfer ，或者增长链表，或者给红黑树增加节点
4. 检查满足 阈值 就 红黑树化
5. 返回oldVal

#### get流程

1. 计算hash值
2. 找到对应的位置，根据情况进行
3. 直接取值
4. 红黑树里找值
5. 遍历链表取值
6. 返回找到的结果

#### 为什么要把1.7的结构改成1.8的结构

- 数据结构。从原来的 默认16segment到1.8的每个独立的Node。并发提高了
- Hash碰撞
- 保证并发安全
- 查询复杂度。

#### 组合操作

~~~java
boolean replace(K key,V oldValue,V newValue)
//往里面填值
V putIfAbsent(K key)
//判断有没有这个kye，有就返回当前这个key中的value，没有就将key 和 value添加进去
~~~

## CopyOnWriteArrayList

代替Vector和SynchronizedList，就和CocurrentHashMap代替SynchronizedMap的原因一样

Vector和SynchronizedList的锁的粒度太大，并发效率相对较低，并且迭代时无法编辑

Copy-On-Write并发容器还包括CopyOnWriteArraySet，用来替代同步Set

#### 适用场景

读操作可以尽可能地快，而写即使慢一些也没有太大关系。

读多写少：黑名单，每日更新；监听器：迭代操作远多余修改操作

回滚读写锁：读读共享、其他都互斥(读写互斥，写读互斥，写写互斥 )

读写锁规则的升级：读取是完全不用加锁的，并且更厉害的是，写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。

CopyOnWrite的含义：在计算机中对内存进行修改的话 ，有一种策略我不对这个内存进行修改。把这块内存copy一份，然后把拷贝的东西放到新内存中。把原来指向copy前的那个内存的指针调用到我现在copy好的新内存中

创建新副本，读写分离。

不可变原理。

#### 缺点

数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所有如果你希望写入的数据，马上能读到，请不要使用CopyOnWrite容器  

内存占用问题：因为CopyOnWrite的写是复制机制，所有在进行写操作的时候，内存里会驻扎两个对象的内存。

## 并发队列：阻塞队列

### 为什么要使用队列

用队列可以在线程间传递数据：生产者消费者模式，银行转账

### 并发队列简介

Queue 用来保存一组等待处理数据 

BlockingQueue 阻塞队列

### 各并发队列关系图

![](images/%E9%98%9F%E5%88%97%E7%B1%BB%E5%9B%BE.png)

### 阻塞队列 BlockingQueue

#### 什么是阻塞队列

阻塞队列是具有阻塞功能的队列，所有它首先是一个队列，其次是具有阻塞功能。

通常，阻塞队列的一段是给生成者放数据用的，另一端给消费者拿数据用。阻塞队列是线程安全的，所有生产者和消费者都可以是多线程的。

是否有界(容量有多大)。

阻塞队列和线程池的关系：阻塞队列是线程池的重要组成部分。

#### 主要方法介绍

~~~java
E take()
//获取并移除队列的头节点，一旦如果执行take的时候，队列里无数据，则阻塞，直到队列里有数据

put()
//插入元素，但是如果队列已满，那么无法继续插入，则阻塞，直到队列里有了空闲空间
~~~

#### BlockingQueue

put,take 为空阻塞

add,remove,element 为空抛出异常

offer,poll.peek 为空返回null

#### ArrayBlockingQueue

有界。可以指定容量。

公平：还可以指定是否需要保证公平，如果想保证公平的话，那么等待了最长时间的线程会被优先处理，不过这会同时带来一定的性能损耗

####  LinkedBlockingQueue

无界。内部结构。内部结构：Node、两把锁 putLock takeLock

#### PriorityBlokcingQueue

支持优先级，自然顺序，无界队列，PriorityQueue的线程安全版本

#### SynchronizedQueue

容量为0.直接传递(direct handoff)，效率高

注意点：SynchronousQueue没有peek等函数，因为peek的含义是取出头节点，但是SynchronoutQueue的容量为0，所有连头节点都没有，也就没有peek方法。同理没有iterate相关方法。是一个极好的用来直接传递的并发数据结构。SynchronoutsQueue是线程池Executors.newCachedThreadPool()使用的阻塞队列

#### DealyQueue

延迟队列，根据延迟时间排序。元素必须实现Delayed接口，规定排序规则。无界

### 非阻塞并发队列

并发包中的非阻塞队列只有<b style="color:red">ConcurrentLinkedQueue</b>这一种，顾名思义ConcurrentLinkedQueue是使用链表作为其数据结构 的，使用CAS非阻塞算法来实现线程安全，适用在对性能要求较高的并发场景。用的相对比较少一些。

源码中offer方法的CAS思想，内有p.casNext方法，用了UNSAFE.compareAndSwapObject

### 如何选择自己合适的队列

边界。容量

空间。存储的空间

吞吐量。性能角度来讲LinkedBlockingQueue吞吐量一般优于ArrayBlockingQueue，因为他的锁的粒度更加细致，putLock takeLock。



