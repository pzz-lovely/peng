# 原子类Atomic

### 什么是原子类

不可分割。

一个操作是 不可中断的，即使是多线的情况下也可以保证。

java.util.concurrent.atomic这个包下的类都是 原子操作类。

作用：原子类的作用和锁类似，是为了保证并发情况下线程安全。不过原子类相比于锁，有一定的优势：第一个优势：粒度更细，原子变量可以把竞争范围缩小到变量级别，这是我们可以获得的最细粒度的情况了，通常锁的粒度都要大于原子变量的粒度。第二个优势，效率更高，通常，使用原子类的效率会比使用锁的效率更高，除了高度竞争的情况。

### 6类原子类总览

|               类名                |                             类型                             |
| :-------------------------------: | :----------------------------------------------------------: |
|       Atomic* 基本类型原子        |       AtomicInteger<br />AtomicLong<br />AtomicBoolean       |
|    Atomic*Array 数组类型原子类    | AtomicIntegerArray<br />AtomicLongArray<br />AtomicReferenceArray |
| Atomic*Reference 引用类型原子 类  | AtomicReference<br />AtomicAStampedReference<br />AtomicMarkableReference |
| Atomic*FieldUpdate 升级类型原子类 | AtomicIntegerFieldUpdater<br />AtomicLongFieldUpdate<br />AtomicReferenceFieldUpdater |
|            Adder类加器            |                  LongAdder<br />DoubleAdder                  |
|         Accumulator累加器         |            LongAccumulator<br />DoubleAccumulator            |

### Atomic*基本类型原子 

~~~java
	/*AotmicInteger*/
public final int get();
//获取当前的值
public final int getAndSet(int newValue)
//获取当前的值，并设置新的值
public final int getAndIncrement() 
//获取当前的值，并自增 
public final int getAndDecremnt()
//获取当前的值，并自减
public final int getAndAdd(int delta)
//获取当前的值，并加上预期的值
boolean compareAndSet(int expect,int update)
//如果当前的数值等于预期值，则以原子方式将该值设置为输入值(update)
~~~

### Atomic*Array 数组类 跟上面是一样的只不过是数组存储了

### Atomic*Reference 引用类型原子类

AtomicReference ：AtomicReference类的作用，和AtomicInteger并没有本质区别 ，AtomicIntger可以让一个整数保证原子性，而AtomicReference可以让一个对象保证原子性，当然AtomicReference的功能明显比AtomicInteger强，因为一个对象里可以包含很多属性。用法和AtomicInteger类似。

### AtomicIntegerFieldUpdater对普通变量进行升级

有点像反射的使用。

~~~java
AtomicIntegerFieldUpdater atomicIntegerFieldUpdater = AtomicIntgerFieldUpdater.newUpdater(Class<U> tclass,String fieldName);
~~~



使用场景：偶然需要一个原子get-set操作。很少使用

可见范围：不允许private

不支持static变量

### Adder累加器 *

- 是Java8引入的，相对是比较新的一个类。
- 高并发下LongAdder比AtomicLong效率高，不过本质是 <b style="color:red">空间换时间</b>
- 在竞争激励的时候，LongAdder把不同线程对应到不同的Cell上进行修改，降低了冲突的概念，是多段锁的理念，提高了并发性 

AotmicLong由于竞争很激励，每一次加法，都要flush和refersh，导致耗费资源。 

原因：AtomicLong 每次读取到一次数据都是从内存中读取数据(内存 ->refersh -> 本地内存)，修改后的数据 从本地内存 -> flush -> 主存中。

LongAdder 是在自己线程中的本地内存，给值进行计数的，而不会将值写回到主内存中。<span style="color:gray">直到你调用了sum，其他的线程才会将自己相加的 数 写回到内存。{自己理解的，但是不对}</span>

LongAdder引入了分段累加的概念，内部有一个base变量和一个Cell[]数组共同参与计数：

base变量：竞争不激烈，直接累加到该变量上。

Cell[]数组：竞争激烈，各个线程分散累加到自己的槽Cell[i]中。

#### 对比

在低争用下，AtomicLong和LongAdder这两个类具有相似的特征。但是在竞争激励的情况下，LongAdder的预期吞吐量要高的多，但要消耗更多的空间。

LongAdder适合的场景是统计求和计数的场景，而且LongAdder基本只提供了Add方法，而AtomicLong还具有cas方法。

### Accumulator累加器

~~~java
LongAccumulator((LongBinaryOperator accumulatorFunction, long identity);
//LongBinaryOperator是一个函数式接口
void accumulate(long x);
//根据实现的LongBinaryOperator接口的方法 来进行对 x的值
Long getThenReset();
//操作后的值
~~~

使用场景：适合于大量计算，并且是并发执行

