# 线程池

### 什么是 "池" 

软件中的"池"，可以理解为计划经济。 

## 线程池

​																<span color="red"><b>构造方法参数</b></span>

|    参数名     |           类型           |                             含义                             |
| :-----------: | :----------------------: | :----------------------------------------------------------: |
| corePoolSize  |           int            |                          核心线程数                          |
|  maxPoolSize  |           int            |                          最大线程数                          |
| keepAliveTime |           long           |                         保持存活时间                         |
|   workQueue   |      BlockingQueue       |                         任务存储队列                         |
| threadFactory |      ThreadFactory       | 当线程池需要新的线程的时候，会使用threadFactory来生成新的线程 |
|    Handler    | RejectedExecutionHandler |       由于线程池无法接受你所提交的任务 而执行拒绝策略        |

corePoolSize 指的是 核心线程数 ：线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时，在创建新线程执行任务

<b>maxPoolSize：</b>线程池有可能会在核心线程的基础上，额外增加一些线程，但是这些新增的线程数有一个上限，这就是最大量maxPoolSize。

<b>keepAliveTime：</b>如果线程池当前的线程多余corePoolSize，那么多余的线程空闲时间 超过了keepAliveTime，它们就会被终止。

<b>threadFactory</b>由 ThreadFactory创建的，默认使用Executors.defaultThreadFactory()，创建出来的线程都在 同一个线程组 ，拥有同样的NORM_PRIORITY优先级并且都是守护线程。如果自己制定ThreadFactory，那么就可以改变 线程名，线程组，优先级，是否是守护线程等。

<b>workQueue：</b>有几三种最常见的队列类型，直接交接 SynchronizedQueue；无界队列 LinkedBlockingQueue；有界的队列 ArrayBlockingQueue  DelayWorkQueue 延迟工作队列

### 添加原则

1. 如果线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建新线程来运行新任务。
2. 如果线程数等于(或大于)corePoolSize但少于maximunPoolSize，则将任务放入队列。
3. 如果队列已满，并且线程数小于maxPoolSize，则创建一个线程来运行任务 
4. 如果队列，最大线程数 都满了，就执行 拒绝策略。

![](images\线程池添加线程规则  .png)

### 增减线程的特点

1. 通过设置corePoolSize和maxumumPoolSize相同，就可以创建 固定 大小的 线程池。
2. 线程池 希望保持较少的线程数，并且只有在负载变得很大时才 增加它。
3. 通过设置maximumPoolSzie为很高的值，例如Integer.MAX_VALUE，可以允许线程池容量任意数量的并发任务
4. 是只有在队列填满时才创建多余corePoolSize的线程，所以使用的是无界队列 (例如 LinkedBlockingQueue)，那么线程数就不会超过corePoolSize 

### 线程池应该手动创建 还是自动创建

手动创建更好，因为这样可以我们更加明确线程池的运行规则，避免资源消耗尽的风险。

##### 自动创建线程池带来的风险。

1. <b>newFixedThreadPool</b> 由于传进去的LinkedBlockingQueue是没有容量上限的，所以当请求数越来越多，并且无法及时处理完毕的时候，也就是说请求堆积的时候，会占用大量的内存，可能会导致OOM。
2. <b>newSingleThreadPool</b> 和newFixedThreadPool的原理基本一样，只不过源码中 直接设置 成了1，也会导致和newFixedThreadPool一样。
3. <b>newCacheThreadPool</b> 直接交换队列SynchronizedQueue 可缓存的线程池 特点：无界队列。线程池，具有自动回收多余线程的功能。缺点: 在于第二个参数maxumumPoolSize被设置为了Integer.MAX_VALUE，这可能会创建数量非常多的线程，甚至导致OOM。![](D:\task\peng_imooc\juc\src\main\resources\images\CachedThreadPool .png)
4. <b>ScheduledThreadPool</b> 支持周期性任务执行的线程池。
5. ![](images\线程池参数对比.png)

#### 阻塞队列分析

fixedThreadPool和SingleThreadExecutor的Queue是 LinkedBlockingQueue。

CacheThreadPool使用的Queue是 SynchronizedQueue。

ScheduledThreadPool来说 ，它使用的是延迟队列DelayedWorkQueue。

workStealingPool是JDK1.8加入的。和之前的都有很大不同。使用场景 可以产生子任务就是这个。二叉树的遍历，矩阵。用于窃取能力，这个子任务会放到每个线程自己独有的任务队列中，而不是公共队列。比如 说有 三个线程 ，第一个线程产生了 很多子任务。这个子任务会放到 自己的队列中去，然后慢慢执行。假设后面两个线程没事可做了，它们会帮助第一个线程，去把第一个线程 中的自己的队列任务取出来，这个时候 第二个第三个任务 会被 执行。

### 线程池里的线程数量设定为比较合适?

- CPU密集运算(加密、计算hash等)：最佳线程数为CPU核心数的1-2倍
- 耗时IO性(读写数据库、文件、网络读写等)：最佳线程数一般会大于cpu核心数很多倍，以JVM线程监控显示繁忙情况为依据，保证线程空闲可以衔接上。参考<span style="color:red">Brain Goetz</span> 推荐的计算方法
- 线程数 = CPU 核心数 * (1 + 平均等待时间 / 平均工作时间)

### 停止线程池的正确方法

1. shutdown ：把这个线程关闭。实际上你调用了这个方法，它并不会停止，仅仅是初始化关闭过程。等待 线程中 所有的任务都执行完毕，在关闭。但是新的任务 会执行拒绝策略
2. isShutdown 这个线程池是否已经停止 ，并不是完全停止，是否进入停止的状态。
3. isTerminated 返回这个线程池 是否是完全停止的
4. boolean awaitTermination 等待一段时间，查看是否停止线程池。是用来测试  关闭。 在等待之前是阻塞的。
5. shutdownNow 立即关闭线程池。会将 未执行完的 线程中断，而会返回队列中的任务。 ·

### 拒绝策略 

#### 拒绝时机 

1. 当Executor关闭时，提交新任务会被拒绝
2. 当Executor对最大线程和工作队列容量使用有限边界并且 已经饱和时

![](D:\task\peng_imooc\juc\src\main\resources\images\线程池拒绝任务.png)

#### 4中拒绝策略

- AbortPolicy 直接抛出一个异常。
- DiscardPolicy 直接丢弃任务，不会得到通知
- DiscardOldestPolic y 丢弃 存在时间最久的任务。
- CallerRunPolicy 让提交任务的线程执行。

#### 钩子方法，给线程池加点料

每个任务执行前后，加上 日志，统计

~~~java
public class PauseableThreadPool extends ThreadPoolExecutor {
    private boolean isPaused;
    Lock lock = new ReentrantLock();
    private Condition unPaused = lock.newCondition();
    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
    }

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    }

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    }

    private void pause(){
        lock.lock();
        try{
            isPaused = true;
        }finally {
            lock.unlock();
        }
    }

    private void resume(){
        lock.lock();
        try{
            isPaused  = false;
            unPaused.signalAll();
        }finally {
            lock.unlock();
        }
    }

    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        lock.lock();
        try{
            while (isPaused) {
                unPaused.await();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
~~~

### 线程池组成部分

- 线程池管理器  
- 工作线程 
- 任务队列 
- 任务接口 

### Executor家族

线程池、ThreadPoolExecutor、ExecutorService、Executor、Executors等 
![](D:\task\peng_imooc\juc\src\main\resources\images\threadPool.png)

### 线程池实现任务复用的原理

相同线程执行不同任务，通过Worker中的 runWoker方法

线程池状态

1. Running 接受新任务并处理排队任务
2. SHUTDOWN 不接受新任务，但处理排队任务
3. STOP : 不接受新任务，也不处理排队任务，并中断正在进行的任务
4. TIDYING ，中文是正整洁。所有的任务都以终止，workerCount为零时，线程会转换到TIDYING状态，并运行terminate()钩子方法。
5. terminated : terminate()运行完成 

#### 线程池提交方法

execute(Runnable x)没有返回值。可以直接执行任务，但无妨判断任务是否成功完成

submit(Callable x)返回一个future。可以用这个future来判断任务是否成功完成



