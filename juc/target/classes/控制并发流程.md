# 控制并发流程

### 什么是 控制并发流程

控制并发流程的工具类，作用就是帮助我们程序员更容易的让线程之间合作。

​											<b style="color:red">控制并发流程的工具类</b>

|       类       |                             作用                             |                             说明                             |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|    Semahore    |   信号量，可以通过控制"许可证"的数量，来保证线程之间的配合   | 线程只有在拿到 "许可证"后才能继续执行。相比于其他同步器，更灵活 |
| CyclicBarrier  | 线程会等待，直到足够多线程达到了事先规定的数目。一旦达到触发条件，就可以进行下一步的动作 |           适用于线程之间相互等待处理结果就绪的场景           |
|     Phaser     |              和CyclicBarrier类似，但是计数可变               |                         java7加入的                          |
| CountDownLatch |         和CyclicBarrier类似，数量递减到0时，触发动作         |                         不可重复使用                         |
|   Exchanger    |                  让两个线程在合适时交换对象                  | 适用场景：当两个线程工作在同一个类的不同实例上时，用于交换数据 |
|   Condition    |                  可以控制线程的"等待"和唤醒                  |                   是Object.wait()的升级版                    |



### CountDownLatch倒计时门闩

倒数门闩。

例子：拼多多拼团；大巴，人满发车。

流程：倒数结束之前，一直处于<b style="color:red">等待</b>状态，直到倒计时结束了，此线程才继续工作。

~~~java
CountDownLatch(int count)
//仅有一个构造函数，参数count为需要倒数的数值

void await()
//调用await()方法的线程会被挂起，他会等待直到count值为0才继续执行 
    
void countDown()
//将count值减1，直到为0时，等待的线程会被唤起
~~~

![](D:%5Ctask%5Cpeng_imooc%5Cjuc%5Csrc%5Cmain%5Cresources%5Cimages%5CCountDownLatch%201.png)

用法一：一个线程等待多个线程都执行完毕，在继续增加的工作

用法二：多个线程等到某一个线程的信号，同时开始执行 

#### 注意点

扩展用法：多个线程等多个线程完成执行后，在同时执行。多等多

CountDownLatch不能重用的，如果需要重新计数，可以考虑使用CyclicBarrier或者重新创建新的CountDownLatch实例

### Semaphore信号量

Semaphore可以用来<b style="color:red">限制</b>或管理数量<b style="color:red">有限的资源</b>的使用情况。

信号量的作用是维护一个"许可证"的计数，线程可以"获取"许可证，那信号量剩余的许可证就减一，线程也可以"是否"一个许可证，那信号量剩余的许可证就加一，当信号量所拥有许可证数量为0，那么下一个还想要获取许可证的线程，就需要等待，直到有另外的线程释放了许可证。

#### 使用流程

1. 初始化Semaphore并指定许可证的数量
2. 在需要被现在的代码前加acquire()或者acquireUninterruptibly()方法
3. 在任务执行结束后，调用release()来释放许可证

#### 重要方法

~~~java
Semaphore(int permits)
Semaphore(int permits,boolean fair)
//可以设置释放要使用公平策略，如果传入ture，那么Semaphore会把之前等待的线程放入FIFO的队列里，(先进后出)，以便于当有了新的许可证，可以分发给之前等了最长时间的线程

acquire()
acquire(int permits)
//获取一个信号量,可以响应中断
    //获取指定permits值的信号量
acquireUninterruptibly()
    

boolean tryAcqurie(long timeout)    
boolean tryAcqurie()
//看看现在有没有空闲的许可证，如果有的化获取，如果没有的话也没关系，我不必陷入阻塞，我可以去做别的是，过一会再来看看许可证的空闲情况，立即返回
	//timeout 会等待一定时间拿到信号量 拿到了返回ture

void release()
//归还许可证
~~~

#### 特殊用法

一次性获取或释放多个许可证 

​	比如TaskA会调用很消耗资源的method1()，而TaskB调用的是不太消耗资源的method2()，假设我们一共有5个许可证。那么我们就可以要求TaskA获取5个许可证才能执行，而TaskB值需要获取到一个许可证就能执行，这样就避免了A和B同时运行的情况，我们可以自己的需求合理分配资源

#### 注意点

1. 获取和释放的许可证数量必须一致，否则比如每次获取2个但是只释放1个甚至不释放，随着时间的推移，到最后许可证数量不够用，会导致程序卡死。
2. 再初始化Semaphore的时候设置公平性，一般设置为true更为合理 
3. 并不是必须有获取许可证的线程释放那个许可证，事实上，<b style="color:red">获取和释放许可证对线程并无要求，也许是A获取了，然后由B释放</b>，只要逻辑合理即可。
4. 信号量的作用，除了控制临界区最多同时有N个线程访问外，另一个作用是可以实现"条件等待"，例如线程1需要在线程2完成准备工作才能开始工作，那么就线程acquire()，而线程2完成任务后release()，这样的话，相当于轻量级的CountDownLatch。

### Condition接口 条件对象

#### 作用

- 当线程1需要等待某个条件的时候，他就去执行<b style="color:red">condition.await()</b>方法，一旦执行了awati()方法，线程就会进入 <b style="color:red">阻塞</b>状态
- 然后通常会有另外一个线程，假设是线程2，去执行对应的条件，直到这个条件达成的时候，线程2就会去执行<b style="color:red">condition.singal()</b>方法，这时JVM就会从被阻塞的线程里找，找到那些等待该condition的线程，当线程1就会收到可执行信号的时候，它的线程状态就会变成 <b style="color:red">Runnable</b> 可之心状态

#### 方法

~~~java
void signalAll()
//会唤起所有的正在等待的线程 

void singal()
//singal是公平的，只会唤起那个等待时间最长的线程
~~~



#### 注意点 

Condition就是用来代替相对应的Object.wait/notify的。所以在用法和性质上，几乎都一样

await方法会自动释放持有的Lock，和Object.wait一样，不需要自己手动先释放锁

调用await的时候，必须持有锁，否则会抛出异常 ，和Object.wait一样。

### CyclicBarrier循环栅栏

CyclicBarrier循环栅栏和CountDownLatch很类似，都能阻塞一组线程。

当有大量线程相互配合，分别计算不同任务，并且需要最后统一汇总的时候，我们可以使用CycliBarrier。CyclicBarrier可以构造一个集结点，当某个线程都到了集结点，那么该栅栏就被撤销，所有线程在统一出发，继续执行剩下的任务。

作用不同：CyclicBarrier要等固定数量的线程都到达了栅栏位置才能继续执行，而CountDownLatch只需等待数据到0，也就是说，CountDownLatch用于事件，但是CyclicBarrier是用于线程的。

可重用性不同：CountDownLatch在倒数到0并触发门闩打开后，就不能再次使用了，除非创建新的实例；而CyclicBarrier可以重复使用

~~~java
CyclicBarrier(int parties)
//设置集结点数量
CyclicBarrier(int parties,Runnable barrierAction)
//设置集结点数量，并设置达到屏障点后要执行的子线程

int await()
//等待线程数量达到集结点
int await(long timeout,TimeUnit unit)
//等待线程数量达到集结点，并设置等待超时时间
int getNumberWaiting()
//获取等待子线程的数量

void reset();
//重置集结点数量

boolean isBroken()
//查询是否为中断状态

int getParties()
//获取屏障点数量
~~~

