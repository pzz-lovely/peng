# Lock

### 简介、地位、作用

锁是一种工具，用于控制对共享资源的访问。

- Lock和Synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是在使用时几个和功能上又有较大的不同。
- Lock并不是用来代替synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是在使用上和功能上又有较大的不同
- Lock并不是代替 synchronized的，而是当使用synchronized不合适或不满足要求去的时候，来提供高级功能

Lock接口最常见的实现类是 ReentrantLock

通常情况下，Lock只允许一个线程来访问这个共享资源。不过有的时候，一些特殊的实现也可允许 并发访问，比如ReadWriteLock里面的 ReadLock。

### 为什么synchronized不够用？为什么需要Lock?

1. <b style="color:red">效率低</b>：锁的释放情况少，试图获得锁时不能设定超时，不能中断一个正在试图获得锁的线程。
2. <b style="color:red">不够灵活（读写锁更灵活）：</b>加锁和释放的时机单一，每个锁仅有单一的条件(某个对象)，可能是不够的。
3. 无法知道是否<b style="color:red">成功获取到锁</b>

### Lock方法介绍

在Lock中声明了四个方法来获取锁 。Lock不会像synchronzied一样在异常时自动释放锁

~~~java
void Lock() 
//就是最普通的获取锁。如果锁已被其他线程获取，则进行等待
boolean tryLock() 
//用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，则返回true，否则返回false，代表获取锁失败。可以根据是否能获取到锁来决定后续程序的行为。
boolean tryLock(long time,TimeUnit unit) 
//超时就放弃。给定时间内拿到锁了返回true,没有拿到返回false 
void lockInterruptibly() 
//把超时时间设置为无限，在等待锁的过程中，线程可以被中断。
int getHoldCount()
// 获取拿到锁的次数。
void unlock() 
//解锁
~~~



### 可见性保证

happens-before：这件事发生了，其他线程一定能看到怎么之前所做的修改

Lock的加解锁和 synchronized有同样的内存 语义，也就是说，下一个线程加锁后可以看到所有前一个线程解锁前发生的所有操作。

## 锁的分类 

| 线程要不要锁住同步资源 |   锁   |
| :--------------------: | :----: |
|       锁住[互斥]       | 悲观锁 |
|     不锁住[非互斥]     | 乐观锁 |

| 多线程能否共享一把锁 |   锁   |
| :------------------: | :----: |
|         共享         | 共享锁 |
|        不共享        | 独占锁 |

|   多线程竞争时，是否排队   |    锁    |
| :------------------------: | :------: |
|            排队            |  公平锁  |
| 先尝试插队，插队失败在排队 | 非公平锁 |

| 同一个线程是否可以重复获取同一把锁 |     锁     |
| :--------------------------------: | :--------: |
|                可以                |  可重入锁  |
|               不可以               | 不可重入锁 |

| 是否可中断 |     锁     |
| :--------: | :--------: |
|    可以    |  可中断锁  |
|   不可以   | 非可中断锁 |

| 等锁的过程 |    锁    |
| :--------: | :------: |
|    自旋    |  自旋锁  |
|    阻塞    | 非自旋锁 |



### 乐观锁和悲观锁

乐观锁 [非互斥同步锁] 悲观锁[互斥同步锁]

#### 悲观锁

认为自己在操作的过程中有其他线程对数据进行修改，悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问改数据，这样就可以确保数据内容万无一失了。 java中悲观锁的实现就是 synchronized和Lock相关类。

#### 互斥同步锁【悲观锁】劣势

1. 阻塞和唤醒带来的性能劣势。悲观锁锁住之后是<b style="color:red">独占</b>的，其他线程想要拿到锁必须等待。
2. 永久阻塞：如果持有锁的线程被永久阻塞，比如遇到了无限循环，死锁等活跃性问题。如果悲观锁不释放锁，那么其他线程将会永远得不到执行。
3. 优先级反转。一旦优先级低的线程拿到了锁，优先级高的反而要等优先级低的释放锁。

#### 乐观锁[非互斥同步锁]

1. 认为自己在处理操作的过程中不会有其他线程来干扰，所以并不会锁住 被操作对象
2. 在更新的时候，去对比我在修改期间 数据有没有被其他人 改变过：如果没被改变过，就说明真的只是我自己在操作，那我就去正常去修改数据。
3. 如果数据和我 一开始拿到的不一样了，说明其他人在这段时内修改过数据，那我就不能继续刚才的更新过程了，我会放弃、报错。重试等策略
4. 乐观锁的实现一般 都是 利用 <b style="color:red">CAS</b> 算法来实现的

乐观锁 典型例子就是 <b style="color:red">原子类、并发容器 </b> 等

![](images/%E4%B9%90%E8%A7%82%E9%94%81%E4%BE%8B%E5%AD%90.png)

数据库:

​		select for update 就是 悲观锁
​		用version控制数据库就是乐观锁

#### 开销对比

- 悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临时区持锁时间就算越来越长，也不会对 互斥锁 开销造成影响。
- 相反，乐观锁一开始的开销比 悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多。

#### 使用场景 

**临界区**指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个 线程 访问的特性。

悲观锁：适合并发写入多的情况，适用于临界区持锁时间比较长的情况，可以让一些抢不到的资源去等待，悲观锁可以避免大量的无用自旋等消耗。典型情况 :

1. 临界区有IO操作
2. 临界区代码复杂或者循环量 大
3. 临界区 竞争非常激烈

乐观锁 ：适合并发写入少，大部分是读取的场景。

### 可重入锁和非可重入锁，已ReetrantLock为例

同一个线程 可以获取多个锁。

好处：避免死锁。提高封装性。

方法：

​		isHeldByCurrentThread可以看出锁是否被当前线程持有 

​		getQueueLength 可以返回当前正在等待这把锁的队列有多长，一拿这个两个方法是开发调式时候使用，上线后用到不多。

### 公平锁和非公平锁

公平指的是按照线程请求的顺序，来分配锁；

非公平指的是，不完全按照请求的顺序，在一定情况下，可以插队。

tryLoc()它不遵守设定的公平的规则。当有线程执行tryLock()的时候，一旦有线程释放了锁，那么这个正在tryLock的线程就能获取到锁，即使在它之前已经有其他现在在等待队列里了。

|    锁    |                             优势                             |                             劣势                             |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  公平锁  | 各线程公平平等，每个线程在等待一段时间后<br />，总有执行的机会 |                       更慢，吞吐量更小                       |
| 不公平锁 |                        更快，吞吐量大                        | 有可能产生线程饥饿，<br />也就是某些线程在长时间内，始终得不到执行 |



### 共享锁和排他锁

共享锁和排他锁的典型是读写锁 ReentrantReadWriteLock，其中读锁是共享锁，写锁是独占锁。

在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读时无阻塞的，提高了程序的执行效率。

读写锁只是一把锁，可以通过两种方式来进行锁定：<b style="color:red">读锁定和写锁定</b>，读写锁可以同时被一个或多个线程锁定，也可被单一线程写锁定。

#### 排他锁

又称独占锁，独享锁。synchronzied

#### 共享锁 

又称读锁，获得共享锁之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但无法修改和删除数据。

#### 读锁和写锁的交互方式

1. 选择规则 从等待队列里面选择那个线程来执行
2. 读线程插队 (比喻：男女共用厕所，男生可以插队吗？)
3. 升降级 读锁和写锁时不平等的。写锁是高级，读锁是低级。写锁降为读锁。

##### 读锁插队策略 选择了策略2

场景：非公平：假设线程2和线程4正在同时读取，线程3想要写入，拿不到锁，于是进入等待队列，读线程5不在队列中，现在过来想要读取

策略1：让5插队，插到3前面。读可以插队，效率高。但是可能会让 线程3会进入到锁饥饿的情况。有可能后面一直来读线程

策略2：不然5插队，而是等待3执行完。避免饥饿。 

公平锁：不允许插队

非公平锁：写锁可以随时插队。读锁仅在等待 队列头节点不是想获取写锁的线程可以插队，

#### 锁的升降级

支持锁的降级，不支持升级。

~~~java
writeLock.lock();
readLock.lock();
readLock.unlock();
writeLock.unlock();
//降级是可以的

readLock.lock();
writeLock.lock();
writeLock.unlock();
readLock.unlock();
//升级是不行的。
~~~

不支持锁的升级。两个线程都持有读锁，这个两个锁都想升级成写锁，但是只允许一个写或多个读。这就可能这两个线程都在等对方释放掉锁，这就会死锁了

### 总结

1. ReentrantReadWriteLock实现了ReadWriteLock接口，最主要的有两个方法:readLock()和writeLock()用来获取读锁和写锁
2. 锁申请和释放策略：A：多个线程申请读锁，都可以申请到 B：如果有一个线程已经独占读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。C：如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或读锁，则申请的线程会一直等待释放写锁 D：要么是一个或多个线程同时持有读锁，要么是一个线程有写锁，但是两者都不会同时出现。
3. 插队策略：为了防止饥饿，读锁不能插队
4. 升降级策略：只能降级，不能升级
5. 使用场合：相比于ReentrantLock适用于一般场合，ReentrantReadWriteLock适用于<b style="color:red">读多写少</b>的情况，合理使用可以进一步提高并发效率。

### 自旋锁和阻塞锁

阻塞或唤醒一个Java线程 需要操作系统切换CPU状态来完成，这种状态转换需要 耗费 处理器时间。

#### 自旋锁

自旋锁：占着cpu不放，一直获取锁。

缺点：如果锁占用的时间很长，那么自旋的线程只会浪费处理器资源。

在自旋的过程中，一直消耗cpu，所以虽然自旋锁的起始开销低于悲观锁，但是随着咨询的时间的增长，开销也是线性增长的。

在java.1.5版本以上的并发框架java.util.concurrent的atomic 包下的类基本都是自旋锁实现的。

AtomicInteger的实现：自旋锁的实现原理是CAS，AtomictInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改过程中遇到其他线程竞争导致没修改成功，就在whil里死循环，直至修改成功。

自旋锁一般用于多核的服务器，在并发度不是特别高的情况下，比阻塞锁的效率高。

#### 阻塞锁

阻塞锁：如果遇到没弄到锁的情况，会直接把线程阻塞，直到被唤醒 。

### 可中断锁

在java中，synchronzied就不是可中断锁，而Lock是可中断锁，因为tryLock(time)和lockInterruptibly都能响应中断。

## 锁优化 

 #### java虚拟机对所的优化

自旋锁和自适应（如果自旋一直尝试获取到锁，没有获取到就可能转为阻塞锁）。

锁消除。jvm会消除 某些私有的方法 里面的锁。

锁粗化。

### 优化锁和提高 高并发性能

1. 缩小同步代码块
2. 尽量不要锁住方法
3. 减少请求锁的次数
4. 选择合适的锁类型或合适的工具类



