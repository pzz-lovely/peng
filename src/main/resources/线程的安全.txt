    线程安全
        并发编程最重要的部分。
    当多个对象访问一个对象时，如果不应考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的

    对象发布和初始化的时候的安全问题
    发布:把这个对象可以超过这个类的范围的使用。
    逸出:
        方法返回一个private对象
        还未初始化(构造函数没完全执行完毕)就把对象提供给外界
        在构造函数中未初始化完毕就this赋值
        隐式溢出--注册监听事件
        构造函数中运行线程
    初始化:

    各种需要考虑线程安全的情况
        1.访问共享的变量或资源，会有并发风险，比如对象的属性、静态变量、共享缓存，数据库等
        2.所有依赖时序的操作，即使每一步操作都是线程安全的，还是存在并发问题: read-modify-write check-the-act
        3.不同的数据之间存在捆绑关系的时候，要么都修改完毕，要么都不修改
        4.我们使用其他类的时候，如果对方没有声明自己是线程安全的尽量不要使用。

    双刃剑: 多线程会导致的问题

    性能问题有哪些具体实现、什么是性能问题
        单线程的情况，不存在线程调度，不需要考虑上下文切换的开销，也不需要用锁，不需要并发。
    为什么多线程会带来性能问题
        调度:上下文切换
            什么是上下文?
                上下文:就是当前线程所保存的环境context
                主要是发生在线程调度的时候，什么时候回发生线程调度呢?当可运行的线程数超过了CPU的数量，那么操作系统就要调度线程了，让线程都可以运行。
                上下文主要是跟寄存器相关的，一次上下文切换，首先要挂起一个线程，然后把目前这个线程状态保存在内存中某处。
            缓存开销:缓存失效
            何时会导致密集的上下文切换
                抢锁 IO
        协作:内存同步
        调度和协作 是相辅相成的

