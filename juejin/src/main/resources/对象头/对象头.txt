java对象保存在内存中
    1.对象头
    2.实例数据
    3.对齐填充字节
1.对象头
    Mark Word记录了对象和锁有关信息，当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关
    Mark Word在32JVM中的长度是32bit，在64位JVM长度是64bit
    无锁:25bit,2bit 对象的HashCode 4bit分代年龄 1bit是否是偏向锁=1  2bit锁标志位=01
    偏向锁 23bit线程ID 2bitEpoch时代 4bit分代年龄 1bit是否是偏向锁=1 2bit锁标志位=01
    轻量级锁 30bit指向栈中锁记录的指针 2bit锁标志位=00
    重要级锁 30bit指向重量级锁的指针 2bit锁标志位=10
    GC标记 30bit空 2bit锁标志位11

    其中无锁和偏向锁标志为都是01，只是在前面的1bit区分了这是无锁状态还是偏向锁状态.

    jdk1.6以后的版本在处理同步锁时存在锁升级的概念，JVM对于同步锁的处理是从偏向锁开始的，随着竞争越来越激烈，处理方式从偏向锁升级为轻量级锁，最终升级到重量级锁
    JVM一般是这样使用锁和Mark Word的:
        1.在没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那第一位是0。
        2.当对象当做同步锁并有一个线程A抢到了锁时，锁标志为还是01，但是偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态
        3.当线程A再次识图获得这个锁时，JVM发现同步锁对象的标志为是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码
        4.当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5
        5.偏向锁状态强索失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象岁Mark Word的指针，同时在对象所Mark Word中保存指向这片空间的指针。上述两个操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志改为00，可以执行同步锁代码。如果保存失败，表示强索失败，竞争太激烈，继续执行步骤6
        6.轻量级锁强锁失败，JVM虎使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步代码块，如果失败继续执行步骤7
        7.自旋锁重试之后如果强索依然失败，同步锁会升级为重量级锁。锁标志为改为10。这个状态下，未抢到锁的线程都会阻塞

    2，指向类的指针
    该指针在32位JVM中的长度是32bit，在64位JVM中长度是64bit。

    Java对象的类数据保存在方法区

    3，数组长度
    只有数组对象保存了这部分数据。

    该数据在32位和64位JVM中长度都是32bit。