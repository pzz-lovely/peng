CountDownLatch,可以翻译为倒计时器。它的含义是允许一个或多个线程等待其他线程的操作执行完毕后再执行后续的操作
CountDownLatch中只包含一个Sync内部类。
内部类 Sync
    private static final class Sync extends AbstractQueuedSynchronizer{
        //传入初始化次数
        Sync(int count){
            setState(count);
        }
        //获取还剩的次数
        int getCount() {
            return getState();
        }
        //尝试获取共享锁
        protected int tryAcquireShared(int acquires){
            //注意，这里state等于0的时候返回的是1，也就是count减为0的时候获取总是成功
            //state不等于0的时候回返回是-1，也就是count不为0的时候总是要排队
            return (getState()==0) ? 1 : -1;
        }

        //尝试释放锁
        protected boolean tryReleaseShared(int releases){
            for(;;){
                int c = getState();
                if(c == 0 )
                    return false;
                int nextc = c -1;
                if(compareAndSetState(c ,nextc))
                    //减为0的时候返回ture,这是会唤醒后面排队的线程
                    return nextc == 0;
            }
        }
    }
    Sync重写了tryAcquireShared()和tryReleaseShared()方法，并把count存到state变量中去。
    CountDownLatch 方法:
        void await(){
            //调用AQS的acquireSharedInterruptibly
            sync.acquireSharedInterruptibly(1);
        }

        java.util.concurrent.AbstractQueuedSynchronizer
        public final void acquireSharedInterruptibly(int arg){
            if(Thread.interrupted())
                throw new InterruptedException();
            //尝试获取锁，如果失败则排队
            if(tryAcquireShared(arg) < 0 )
                doAcquireSharedInterruptibly(arg);
        }
        await()方法是等待其他线程完成的方法，它会先尝试获取一下共享锁，如果失败则进入AQS的队列中排队等待被唤醒
        void countDown(){
            //调用AQS的释放共享锁方法
            sync.releaseShared(1);
        }
        //AbstractQueuedSynchronizer
        public final boolean releaseShared(int arg){
            //尝试释放共享锁，如果成功了，就唤醒排队的线程
            if(tryReleaseShared(arg)){
                doReleaseShared();
                return true;
            }
            return false;
        }
    countDown()方法，会释放一个共享锁，也就是count的次数会减1。


    总结:
        1.CountDownLatch表示允许一个或多个线程等待其他线程的操作执行完毕后再执行后续的操作
        2.countDownLatch使用AQS的共享锁机制实现
        3.CountDownLatch初始化的时候需要传入次数count；
        4.每次调用countDown()方法count的次数减1
        5.每次调用await()方法的时候会尝试获取锁，这里的获取其实是检查AQS的state变量的值是否为0;
        6.当count的值(也就是state的值)减为0的时候会唤醒排队着的线程(这些线程调用await()进入队列)

