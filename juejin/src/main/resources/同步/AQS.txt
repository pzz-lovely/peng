    简介:
    AQS的全称是AbstractQueuedSynchronized它的定位是为java中几乎所有的锁和同步器提供一个基础框架。
    AQS是基于FIFO的队列实现的，并且内部维护了一个状态state，通过原子更新这个状态变量state既可以是实现加锁解锁操作
    核心源码
        主要内部类
        static final class Node{
            //标识一个节点是共享模式
            static final Node SHARED = new Node();
            //标识一个节点是互斥模式
            static final Node EXCLUSIVE = null;

            //标识线程已取消
            static final int CANCELLED = 1;//cancelled
            //标识后继节点需要唤醒
            static fina; int SIGNAL = -1;   //signal
            //标识线程等待在一个条件上
            static final int CONDITION = -2; //condition
            //标识后面的共享锁需要无条件的传播(共享锁需要连续唤醒读的线程)
            static final int PROPAGATE = -3;//propagate

            //当前节点保存的线程对应的等待状态
            volatile int waitStatus;

            //前一个节点
            volatile Node prev;
            //后一个节点
            volatile Node next;

            //当前节点保存的线程
            volatile Thread thread;
            //下一个等待在条件上的节点(Condition锁使用)
            Node nextWaiter;
            //是否是共享模式
            final boolean isShared(){
                return nextWaiter == SHARED;
            }
            //获取前一个节点
            final Node predecessor()throws NullPointException{
                Node p = this.prev;
                if(p  == null)
                    throw new NullPointException();
                else
                    return p;
            }

            //节点的构造方法
            Node(){}    //Used to establish initial hread or SHARED marker
            //节点的构造方法
            Node(Thread thread,Node mode){  //used by addWaiter
                //把共享模式还是互斥模式存储到nextWaiter这个字段里面了
                this.nextWaiter = mode;
                this.thread = thread;
            }

            //节点的构造方法
            Node(Thread thread,int waitStatus ){ //used by Condition
                //等待状态，在Condition中使用
                this.waitStatus = waitStatus;
                this.thread = thread;
            }
        }
    典型的双链表结构，节点中保存着当前线程，前一个节点，后一个节点以及线程的状态等信息。
    主要属性
        //队列的头节点
        private transient volatile Node head;
        //队列的尾节点
        private transient volatile Node tail;
        //控制加锁解锁的变量
        private volatile int state;
        定义了一个状态变量和一个队列，状态变量用来控制加锁解锁 ，队列用来放置等待的线程


        这几个变量的修改是直接使用的Unsafe这个类来操作的：
        //获取Unsafe类的实例，主要这个方式仅限于jdk自己使用，普通用户是无法这样调用的
        private static final Unsafe unsafe = Unsafe.getUnsafe();
        //状态变量state的偏移量
        private static final long stateOffset;
        //头节点的偏移量
        private  static final long headOffset;
        //尾节点的偏移量
        private static final long tailOffset;
        //等待状态的偏移量(Node的属性)
        private static final long nextOffset;
        //初始化
        static{
            try{
                //获取state的偏移量
                stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField("state"));
                //获取head的偏移量
                headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField("head"));
                //获取tail的偏移量
                tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField("tail"));
                // 获取waitStatus的偏移量
                waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField("waitStatus"));
                // 获取next的偏移量
                nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField("next"));
            }catch(Exception ex){throw new Error(ex);}
        }

        //调用unsafe的方法原子更新state
        protected final boolean compareAndSetState(int expect,int update){
            return unsafe.compareAndSwapInt(this,stateOffset,expect,update);
        }

    状态变量state
        AQS中定义了一个状态变量state，它有以下两种使用方法
        1.互斥锁
            当AQS只实现为互斥锁的时候，每次只要原子更新state的值从0变为1成功就获取了锁，可重入是通过不断把state原子更新加1实现的。
        2.互斥锁+共享锁
            当AQS需要同步实现为互斥锁+共享锁的时候，低16位存储互斥锁的状态，高16位存储共享锁的状态，主要用于实现读写锁。
            互斥锁是一种独占锁，每次只允许一个线程独占，且当一个线程独占时，其他线程无法在获取互斥锁及共享锁，但是它自己可以获取共享锁。
            共享锁同时允许多个线程占有，只要一个线程占有了共享锁，所有线程(包括自己)都无法再获取互斥锁，但是可以获取共享锁。
    AQS队列
        AQS中维护了一个队列(内部类Node实现)，获取锁失败(非tryLock())的线程都将进入这个队列中排队，等待锁释放后唤醒下一个排队的线程(互斥锁模式下)。
    Condition队列
        AQS中还有一个非常重要的内部类(ConditionObject)它实现了Condition接口，主要用于实现条件锁。
        ConditionObject中也维护了一个队列，这个队列主要用于等待条件的成立，其它线程将signal这个队列中的元素，将其移动到AQS的队列中，等待占有锁的线程释放后被唤醒。
        Condition典型的运用场景是在BlockingQueue中的实现，当队列为空时，获取元素的线程阻塞在notEmpty条件上，一旦队列中添加了一个元素，将通知notEmpty条件，将其队列中的元素移动到AQS队列中等待被唤醒。

    模板方法
        AQS这个抽象类把模板方法设计模式运用地炉火纯青，它里面定义了一系列的模板方法，比如下面这些：
        //获取互斥锁
        public final void acquire(int arg){
            //tryAcquire(arg)需要子类实现
            if(!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE),arg))
                selfInterrupt();//自我中断
        }

        //获取互斥锁可中断
        public final void acquireInterruptibly(int arg)throw InterruptedException{
            if(!Thread.interrupted())
                throw new InterruptedException();
            //tryAcquire(arg)需要子类实现
            if(!tryAcquire(arg))
                doAcquireShared(arg);   //获取共享
        }

       //获取共享锁
       public final void acquireShared(int arg){
            //tryAcquireShard(arg)需要子类实现
            if(tryAcquireShared(arg) < 0 )
                doAcquireShared(arg);
       }

       //获取共享锁可中断
       public final void acquireSharedInterruptibly(int arg)throws InterruptedException{
            if(Thread.interrupted())
                throw new InterruptedException();
            //tryAcquireShared(arg)需要子类实现
            if(tryAcquireShared(arg) < 0){
                doAcquireSharedInterruptibly(arg);
            }
       }

       //释放互斥锁
       public final boolean release(int arg){
            //tryRelease(arg)需要子类实现
            if(tryRelease(arg)){
                Node h = head;
                if(h != null && h.waitStatus != 0)
                    unparkSuccessor(h);
                return true;
            }
            return false;
       }

        //释放共享锁
        public final boolean releaseShared(int arg){
            //tryReleaseShared(arg)需要子类实现
            if(tryReleaseShared(arg)){
                doReleaseShared();
                return true;
            }
            return false;
        }


    子类需要实现的方法
        我们可以看到AQS的全称是AbstractQueuedSynchronizer，它本质上是一个抽象类，说明它本质上应该是需要子类来实现的，那么子类实现一个同步器需要实现哪些方法呢？
        需要重写的方法
        //互斥模式下使用:尝试获取锁
        protected boolean tryAcquire(int arg){
            throw new UnsupportedOperationException();
        }
        //互斥模式下使用:尝试释放锁
        protected boolean tryRelease(int arg){
            throw new UnsupportedOperationException();
        }
        //共享模式下使用:尝试获取锁
        protected int tryAcquireShared(int arg){
            throw new UnsupportedOperationException();
        }
        //共享模式下使用:尝试释放锁
        protected boolean tryReleaseShared(int arg){
            throw new UnsupportedOperationException();
        }
        //如果当前线程独占着锁，返回true
        protected boolean isHeldExclusively(){
            throw new UnsupportedOperationException();
        }
        问题：这几个方法为什么不直接定义成抽象方法呢？

        因为子类只要实现这几个方法中的一部分就可以实现一个同步器了，所以不需要定义成抽象方法。

    总结:
        （1）AQS是Java中几乎所有锁和同步器的一个基础框架，这里说的是“几乎”，因为有极个别确实没有通过AQS来实现；
        （2）AQS中维护了一个队列，这个队列使用双链表实现，用于保存等待锁排队的线程；
        （3）AQS中维护了一个状态变量，控制这个状态变量就可以实现加锁解锁操作了