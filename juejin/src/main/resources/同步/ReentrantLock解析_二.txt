（1）条件锁是什么？

（2）条件锁适用于什么场景？

（3）条件锁的await()是在其它线程signal()的时候唤醒的吗？
    简介:
        条件锁。是指在获取锁之后发现当前业务场景自己无法处理，二需要等待某个条件的出现才可以继续处理时使用的一种锁。
        比如，在阻塞嘟咧中国，当队列中没有元素的时候是无法弹出一个元素的，这时候就需要阻塞条件notEmpty上，等待其他线程往里面发乳一个元素后，唤醒这个条件notEmpty，当前线程才可以继续去做"弹出一个元素"的行为
        注意，这里的条件，必须是在获取锁之后去等待，对应到ReentrantLock的条件锁，就是获取锁之后才能调用condition.await()方法。
        ConditionObject类的主要属性
        public class ConditionObject implements Condition,java.io.Serializable{
            //first node of condition queue条件队列的第一个节点
            private transient Node firstWaiter;
            //last node of condition lastWaiter
            private transient Node lastWaiter;
        }
        可以看到条件锁中也维护了一个队列，为了和AQS的队列区分，我这里称为条件队列，firstWaiter是队列的头节点，lastWaiter是队列的尾节点，
        lock.newCondition()方法
            新建一个条件锁
            //ReentrantLock.newCondition()
            public Condition newCondition(){
                return sync.newCondition();
            }

            //ReentrantLock.Sync.newCondition()
            final ConditionObject newCondition(){
                return new ConditionObject();
            }

            //AbstractQueuedSynchronizer.ConditionObject.ConditionObject()
            public ConditionObject(){}

    Condition接口:
        condition.await()方法 表示现在要等待条件的出现
        //AbstractQueuedSynchronizer.ConditionObject.await()
        public final void await()throws InterruptedException{
            //如果线程中断了，抛出异常
            if(Thread.interrupted())
                throw new InterruptedException();
            //添加节点到Condition的队列中，并返回该节点
            Node node = addConditionWaiter();
            //完全释放当前线程获取的锁
            //因为锁时是可重入的，所以这里要把获取的锁的全部释放
            int saveState = fullRelease(node);
            int interruptedMode = 0 ;
            //是否在同步队列中
            while(!isOnSyncQueue(node)){
                //阻塞当前线程
                LockSupport.park(this);
                //上面部分是调用await()时释放自己占有的锁，并阻塞自己等待条件出现
                /**************分界线***************/
                //下面部分是条件已经出现，尝试去获取锁
                if((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            //尝试获取锁，注意第二个参数
            //如果没获取到会再次阻塞
            if(acquireQueued(node,saveState) && interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            //清除取消的节点
            if(node.nextWaiter != null) //clean up if cancelled 如果取消则清理
                unlinkCancelledWaiters();
            //线程中断相关
            if(interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }




    总结
        1.重入锁时值可重复获取的锁，即一个线程获取锁之后再尝试获取锁时会自动获取苏
        2.在ReentrantLock中重入锁时通过不断累加state变量的值实现的
        3.ReentrantLock的施法要跟获取匹配，即使取了几次也要施法几次
        4.ReentrantLock默认是非公平模式，因为非公平模式效率更高
        5.条件锁是指为了等待某个条件出现而使用的一种锁
        6.条件锁比较经典的使用场景就是队列为空阻塞在条件notEmpty上
        7.ReentrantLock中的条件锁时通过AQS的ConditionObject内部类实现的
        8.await()和signal()方法都必须在获取之后释放锁之前使用
        9.await()方法会新建一个节点放到条件队列中，接着完全释放锁，然后阻塞当前线程并等待条件的出现
        10.signal()方法会寻找条件队列中第一个可用节点移到AQS队列中
        11.在调用signal()方法的线程调用unlock()方法才真正唤醒阻塞在条件上的节点(此时节点已经在AQS队列中)
        12.之后该节点再次尝试获取锁，后面的逻辑与lock()的逻辑基本一致了
