    简介
    ReentrantReadWriteLock读写锁是一种特殊的锁，它把共享的资源的访问分为读访问和写访问，多个线程可以同时对共享资源进行读访问，但是同一时间只能有一个线程对共享资源进行写访问，使用读写锁可以极大地提高并发量。
    读写锁具有以下的特性:
        是否互斥   读    写
        读        否    是
        写        是    是
        互斥锁只能被一个线程拥有，而共享锁可以被多个线程拥有
        可以看到，读写锁除了读读不互斥，读写、写读、写写都是互斥的。
    ReentrantLockReadWriteLock中的类分成三个部分:
        1.ReentrantReadWriteLock本身实现了ReadWriteLock接口，这个接口值提供了两个方法readLock()和writeLock();
        2.同步器(AbstractQueuedSynchronizer)，包含一个继承了AQS的Sync内部可，以及其两个子类FairSync和NonfairSync
        3.ReadLock和WriteLock两个内部类实现了Lock接口，它们具有锁的一些特性。
    主要属性:
        //读锁
        private final ReentrantReadWriteLock.ReadLock readLock;
        //写锁
        private final ReentrantReadWriteLock.WriteLock writeLock;
        //同步器
        final Sync sync;
        //第一个读者线程
        private transient Thread fristReader = null;
        //读者重入的次数
        private transient int firstHoldCount = 0;

    主要构造方法:
        //默认构造方法 使用非公平锁
        public ReentrantReadWriteLock(){
            this(false);
        }
        //是否使用公平锁的构造方法
        public ReentrantReadWriteLock(boolean fair){
            sync = fair ? new FairSync() : new NonfairSync();
            //初始化读和写锁
            readLock = new ReadLock(this);
            writeLock = new ReadLock(this);
        }

    内部类ReadLock implements Lock;    基于非公平
        方法:
            //ReentrantLock.ReadLock.lock();
            public void lock(){ 获取锁
                sync.acquireShared(1);      //获取共享锁
            }
            //AbstractQueuedSynchronizer.acquireShared();
            public final void acquireShared(int arg){
                //尝试获取共享锁(返回1表示成功，，返回-1表示失败)
                if(tryAcquireShared(arg) < 0){
                    //失败了就可能要排队
                    doAcquireShared(arg);
                }
            }
            //ReentrantReadWriteLock.Sync.tryAcquireShared()
            protected final int tryAcquireShared(int unused){
                Thread current = Thread.currentThread();
                //状态变量的值
                //在读写锁模式下，高16位存储的是共享锁(读锁)被获取的次数，低16位存储的是互斥锁(写锁)被获取的次数
                int c = getState();
                //互斥的次数
                //如果其他线程获得了写锁，直接返回-1
                if(exclusiveCount(c) != 0 && getExclusiveOwnerThread() != current){
                   return -1;
                }
                //读锁获取的次数
                int r = sharedCount(c);
                //下面说明此线程还没有写锁，尝试去更新state的值获取读锁
                //读者是否需要排队(是否是公平模式)
                if(!readShouldBlock() && r < MAX_COUNT && compareAndSetState(c,c+SHARED_UNIT){  //shared_unit 11111111111111110000000000000000 c+1
                    //获取读锁成功
                    if(r == 0){
                        //如果之前还没有线程获取读锁
                        //记录第一个读者为当前线程
                        firstReader = current;
                        //第一个读者重入的次数为1
                        firstReaderHoldCount = 1;
                    }else if(firstReader == current){
                        //如果有线程获取了读锁且是当前线程是第一个读者
                        //则把其重入的次数加1
                        firstReaderHoldCount++;
                    }else {
                        //如果有线程获取了读锁且当前线程不是第一个读者
                        //保存器则从缓冲中获取重入次数
                        HoldCounter rh = cacheHoldCounter;
                        //如果缓存属性不是当前线程
                        //再从ThreadLocal中获取
                        if(rh == null || rh.tid != getThreadId(current))
                            //get()的时候回初始化rh
                            cacheHoldCounter = rh = readHolds.get();
                         else if(rh.count == 0)
                            //如果rh的次数为0，把他放到ThreadLocal中去
                            readHolds.set(rh);
                         //重入的次数加1(初始化次数为0)
                         rh.count++;
                    }
                    //获取读锁成功，返回1
                    return 1;
                }
                //通过这个方法再去尝试获取读锁(如果之前其他线程获取了写锁，一样返回-1表示失败)
                return fullTryAcquireShared(current);
            }

            //AbstractQueuedSynchronizer.doAcquireShard()
            private void doAcquireShard(int arg){
                //进入AQS的队列中
                final Node node = addWaiter(Node.SHARED);
                boolean failed = true;
                try{
                    boolean interrupted = false;
                    for(;;){
                        //当前节点的前一个节点
                        final Node p = node.predecessor();
                        //如果前一个节点是头节点(说明是第一个排队的节点)
                        if(p == head){
                            //再次尝试获取读锁
                            int r = tryAcquireShared(arg);
                            //如果成功了
                            if(r >= 0){
                                //头节点后移并传播
                                //传播即唤醒后面连续的读节点
                                setHeadAndPropagate(node,r);
                                p.nex t= null;  //help GC
                                if(interrupted)
                                    selfInterrupt();
                                failed = false;
                                return;
                            }
                        }
                        //没获取到读锁，阻塞并等待被唤醒
                        if(shouldParkAfterFailedAcquire(p ,node) && parkAndCheckInterrupt())
                            interrupted = true;
                    }
                }finally{
                    if(failed)
                        cancelAcquire(node);
                }
            }

            //AbstractQueuedSynchroinzer.setHeadPropagate();
            private void setHeadAndPropagate(Node node,int propagate){
                //h为旧的头节点
                Node h = read;
                //设置当前节点为新节点
                setHead(node);

                //如果旧的头节点或新的头节点为空或者其等待状态小于0(表示状态为SIGNAL/PROPAGATE)
                if(propagate > 0 || h == null || h.waitStatus < 0|| (h=head)==null || h.waitStatus < 0){
                    //需要传播
                    //取下一个接地那
                    Node s = node.next;
                    //如果下一个节点为空，或者是需要获取读锁的节点
                    if(s == null || s.isShared())
                        doReleaseShared();
                }
            }

            //AbstractQueuedSynchronizer.doReleaseShared();
            //这个方法只会唤醒一个节点
            private void doReleaseShared(){
                for(;;){
                    Node h = head;
                    if(h != null && h != tail){
                        int ws = h.waitStatus;
                        //如果头节点状态为SIGNAL,说明要唤醒下一个节点
                        if(ws == Node.SIGNAL){
                            if(!compareAndSetWaitStatus(h,Node.SIGNAL,0);
                                continue;   //loop to recheck cases;
                        }
                        //唤醒下一个节点
                        unparkSuccessor(h);
                    }else if(ws == 0  &&
                        //把头节点的状态改为PROPAGATE成功才会跳到下面的if
                        ！compareAndSetWaitStatus(h,0,Node.PROPAGATE))
                            continue;   //loop on failed CAS
                        //如果唤醒后head没变，则跳出循环
                        if(h = head)
                            break;
                }
            }
        分析结果:
            1.先尝试获取读锁
            2.如果成功了直接结束
            3.如果失败了，进入doAcquireShared()方法
            4.doAcquireShared()方法中首先会生成一个新节点进入AQS队列中
            5.如果头节点正好是当前节点的上一个节点，再次尝试获取锁
            6.如果成功了，则设置头节点为新节点，并传播
            7.传播即唤醒下一个读节点(如果下一个节点是读节点的话)
            8.如果头接地那不是当前节点的上一个几点或者(5)失败，则阻塞当前线程等待被唤醒
            9.唤醒之后继续走(5)的逻辑
        在整个逻辑中是在哪里连续唤醒读节点的呢？
        答案是在doAcquireShared()方法中，在这里一个节点A获取了读锁后，会唤醒下一个读节点B，这时候B也会获取读锁，然后B继续唤醒C，依次往复，也就是说这里的节点是一个唤醒一个这样的形式，而不是一个节点获取了读锁后一次性唤醒后面所有的读节点。
    ReadLock.unlock()
        //java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock.unlock
        public void unlock(){
            sync.releaseShared(1);
        }
        //java.util.concurrent.locks.AbstractQueuedSynchronizer.releaseShared
        public final boolean releaseShared(int arg){
            //如果尝试释放成功了，就唤醒下一个几点
            if(tryReleaseShared(arg)){
                //这个方法实际是唤醒下一个节点
                doReleaseShared();
                return true;
            }
            return false;
        }
        //java.util.concurrent.locks.ReentrantReadWriteLock.Sync.tryReleaseShared
        protected final boolean tryReleaseShared(int unused){
            Thread current = Thread.currentThread();
            if(firstRead == current){
                //如果第一个读者(读线程)是当前线程
                //就把它重入的次数减1
                //如果减到0了就吧第一个读者置为空
                if(firstReadHoldCount == 1)
                    firstRead = null;
                else
                    firstReadHoldCount--;
            }else {
                //如果第一个读者不是当前线程
                //一样地，把它重入的次数减1
                HoldCount rh = cacheHoldCounter;
                if(rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                int count = rg.count;
                if(count <= 1){
                    readHolds.remove();
                    if(count <= 0)
                        throw unmatchedUnlockException();
                }
                --rh.count;
            }
            for(;;){
                //共享获取的次数减1
                //如果减为0了说明完全释放了，才返回true
                int c = getState();
                int nextc = c - SHARED_UNIT;
                if(compareAndSetState(c,next)){
                    return next 0;
                }
            }
        }

        //java.util.concurrent.locks.AbstractQueuedSynchronizer.doReleaseShared
        //行为跟方法名有点不符，实际是唤醒下一个节点
        private void doReleaseShared(){
            for(;;){
                Node h = head;
                if(h != null && h != tail){
                    int ws = h.waitStatus;
                    //如果头节点状态为SIGNAL，说明要唤醒下一个节点
                    if(ws == Node.SIGNAL){
                        if(!compareAndSetWaitStatus(h,Node.SIGNAL,0))
                            continue;
                            unparkSuccessor(h);
                    }else if(ws == 0
                    && //把头节点的状态改为PROPAGATE成功才会跳到下面的if
                    !compareAndSetWaitStatus(h,0,Node.PROPAGATE)
                        continue;
                }
                //如果唤醒后head没变，则跳出循环
                if(h == head)
                    bread;
            }
        }



    总结:
        1.ReentrantReadWriteLock采用读写锁的思想，能提高并发的吞吐量
        2.读锁使用的是共享锁，多个读锁可以一起获取锁，互相不会影响，即读读不互斥
        3.读写，写读和写读是会互斥的，前者占有着锁，后者需要进入AQS队列中排队
        4.多个连续的读线程是一个接着一个被唤醒的，而不是一次性唤醒所有读线程
        5.只有多个读锁都完全释放的才会唤醒下一个写线程
        6.只有写锁完全释放才会唤醒下一个等待者，这个等待者可能是读线程，也可能是写线程