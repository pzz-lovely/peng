ForkJoin
俩个主要的方法:
    fork() fork()方法类似于线程的Thread.start()方法，它不是真的启动一个线程，而是将任务放入到工作队列中
    joint() join()方法类似于线程的Thread.join()方法，但是它不是简单地阻塞线程，而是利用工作线程运行其他任务。当一个工作线程中调用了join()方法，它将处理其他任务，知道注意到目标任务子任务已经完成了
三个子类:
    RecursiveAction 无返回值任务
    RecursiveTask 有返回值任务
    CountedCompleter 无返回值任务，完成任务后可以触发回调
ForkJointPool内部原理
    ForkJoinPool内部使用的是"工作窃取"算法实现的
        1.每个工作线程都有自己的工作队列WorkQueue
        2.这是一个双端队列，它是线程私有的
        3.ForkJoinTask中fork的子任务，将放入运行该任务的工作线程的对头，工作线程将以LIFO的顺序来处理工作队列的任务
        4.为了最大化利用cpu，空闲的线程将从其他线程的队列中"窃取"任务来执行
        5.从工作队列的尾部窃取任务，以减少竞争
        6.双端队列的操作：push()/pop()仅在其所有者工作线程中调用，poll()是由其他线程窃取任务时调用的
        7.当只剩下最后一个任务时，还是会存在竞争，是通过CAS来实现的