    简介
    synchronized关键字是java中最常用的同步手段，他经过编译之后，会在同步代码块前后分别生成monitorenter和monitorexit字节码指令，这两个字节码都是需要一个引用类型的参数来指明要锁定和解锁的对象
    实现原理
    java内存模型的是，有俩个指令:lock和unlock
    lock锁定，作用于主内存的变量，他把主内存中的变量标识为一条线程独占状态。
    unlock解锁，作用于主内存中的变量，它把锁定的变量释放出来，释放出来的变量才可以被其他线程锁定。
    但是这两个指令并没有直接提供给用户使用，而是提供了两个更高层次的指令 monitorenter 和 monitorexit 来隐式地使用 lock 和 unlock 指令。
    而 synchronized 就是使用 monitorenter 和 monitorexit 这两个指令来实现的。
    根据JVM规范的要求，在执行monitorenter指令的时候，首先要去尝试获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有了这个对象的锁，就把锁的计数器加1，相应地，在执行monitorexit的时候会把计数器减1，当计数器减小为0时，锁就释放了。
    synchronized关键字底层是通过monitorenter和monitorexit实现的，而这两个指令又是通过lock和unlock来实现的。

    而lock和unlock在Java内存模型中是必须满足下面四条规则的:
    1.一个变量同一时刻只允许一条线程对其进行lock操作的，但lock操作可以被同一个线程执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才能解锁。
    2.如果对一个变量执行Lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值
    3.如果一个变量没有被lock操作锁定，则不允许对其执行unlock操作，也不允许unlock一个其他线程锁定变量。
    4.对一个变量执行unlock操作之前，必须把此变量同步回主内存中，即执行store和write操作。
    通过规则（1），我们知道对于lock和unlock之间的代码，同一时刻只允许一个线程访问，所以，synchronized是具有原子性的。
    通过规则（1）（2）和（4），我们知道每次lock和unlock时都会从主内存加载变量或把变量刷新回主内存，而lock和unlock之间的变量（这里是指锁定的变量）是不会被其它线程修改的，所以，synchronized是具有可见性的。
    通过规则（1）和（3），我们知道所有对变量的加锁都要排队进行，且其它线程不允许解锁当前线程锁定的对象，所以，synchronized是具有有序性的。
    综上所述，synchronized是可以保证原子性、可见性和有序性的。

锁优化:
    1.偏向锁，是指一段同步代码一直被一个线程访问，那么这个线程会自动获取锁，降低获取锁的代价。
    2.轻量级锁，是指当前锁时偏向锁时，被另一个线程锁访问，偏向锁会升级为轻量级锁，这个线程会通过自旋得方式尝试获取锁，不会阻塞，调高性能
    3.重量级锁，是指当前线程是轻量级锁时，当自旋了一定的次数后，还没有获取到锁，就会进入阻塞状态，该锁升级为重量级锁，重量级锁会使其他线程阻塞，性能降低

总结:
    1.synchronized在编译时会在同步块前后生成monitorenter和monitoreixt字节码指令
    2.monitorenter和monitorexit字节码指令需要一个引用类型的参数，基本类型不可以
    3.monitenter和monitexit字节码指令更新底层是使用java内存模型的lock和unlock指令
    4.synchronized是可重入锁
    5.synchronized可以同时保证原子性，可见性，有序性
    7.synchronized有三种状态: 偏向锁，轻量级锁，重量级锁