    java中的所，同步器，分布式锁
    1.volatile 易挥发的
    2.synchronized 同步
    3.AQS及Condition条件
    4.ReentrantLock重入锁
    5.ReentrantReadWriteLock 重入读写锁
    6.StampedLock 冲压锁
    7.CountDownLatch 倒数计时
    8.Semaphore 信号
    9.CyclicBarrier 循环壁垒
    1.Phaser 移相器

锁的名词解释 ：
    1.公平锁/非公平锁
    公平锁，是做线程申请的顺序获取锁
    非公平锁，是指不是按照线程的申请的顺序获取
    锁，有可能后申请的线程反而先获取到锁，假如先来的线程一直获取不到锁，会造成锁饥饿的现象
    ReentrantLock中通过构造方法指定是否为公平锁，默认为非公平锁，非公平锁的优点在于吞吐量大。
    synchronized无法指定为公平锁，一直都是非公平锁
    2.可重入锁
    可重入锁，是指一个线程获取锁之后再尝试获取锁时会自动获取锁，可重入锁的优点是避免死锁。
    ReentrantLock和synchronized都是可重入锁
    3.独享锁/共享锁
    独享锁，是指锁一次只能被一个线程持有
    共享锁，是指锁一次可以被多个线程持有
    ReentrantLock和synchronized都是独享锁，ReadWriteLock的读锁时共享锁，写锁时独享锁
    4.互斥锁/读写锁
    与独享锁/共享锁的概念差不多，是独享锁/共享锁的具体实现
    ReentrantLock是synchronized都是互斥锁，ReadWriteLock是读写锁
    5.乐观锁/悲观锁
    悲观锁，是指认为对于同一个数据的并发操作必然会发生修改，即使不会修改也这么认为，所以一定要加锁
    乐观锁，是指认为对于同一个数据的并发操作不一定会发生修改，在更新数据的时候，尝试去更新数据，如果失败就不断尝试。
    悲观锁适用于写操作多的场景，乐观锁适用于读操作多的场景
    6.分段锁
    分段锁，是一种锁的设计思路，他细化了锁的粒度，主要运用在ConcurrentHashMap中，实现高效的并发操作，当才走不需要更新整个数组是，就只锁数组中的一项就可以了。
    7.偏向锁/轻量级锁/重量级锁
    这三个锁只要是支队synchronized进行优化使用的，主要是通过对象监视器在对象头中的字段来表明的。
    偏向锁，是指同一段同步代码被一整个线程访问，那么这个线程城会自动获取锁，降低获取锁的代价。
    轻量级锁，是指当锁时偏向锁时，被另一个线程访问，偏向锁会升级为轻量级锁，这个线程会通过自旋的方式尝试获取锁，不会阻塞，提高性能。
    重量级锁，是指当锁时轻量级锁时，当自旋的线程自旋了一定的次数后，还没有获取到锁，就会进入阻塞状态，该锁升级为重量级锁，重量级级锁虎会是其他线程阻塞，性能降低。
    8.自旋锁
    自旋锁，是指尝试获取锁的线程不会阻塞，而是循环的方式不断获取，这样的好处是线程的上下文切换带来的开锁，提高性能，缺点是循环会消耗CPU。
    9.监视器锁
    synchronized的实现方式，使用monitorenter和monitorexit来实现
    1.mutex锁
    互斥锁，LockSupport.part()底层是通过Mutex实现的
    总结:
    （1）synchronized在编译时会在同步块前后生成monitorenter和monitorexit字节码指令；
    （2）monitorenter和monitorexit字节码指令需要一个引用类型的参数，基本类型不可以哦；
    （3）monitorenter和monitorexit字节码指令更底层是使用Java内存模型的lock和unlock指令；
    （4）synchronized是可重入锁；
    （5）synchronized是非公平锁；
    （6）synchronized可以同时保证原子性、可见性、有序性；
    （7）synchronized有三种状态：偏向锁、轻量级锁、重量级锁；
