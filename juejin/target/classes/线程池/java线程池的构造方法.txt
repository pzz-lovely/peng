    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }

    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             threadFactory, defaultHandler);
    }

    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              RejectedExecutionHandler handler) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), handler);
    }

    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
    ThreadPoolExecutor有四个构造方法,其中三个最终都是调用最后一个，它有7个参数，分分别为corePoolSize,maximumPoolSize,keepAliveTime,unit,workQueue,threadFactory,handler。
    corePoolSize  核心线程数
    当正在运行的线程数。当正在运行的线程数小于核心线程数时，来一个任务就创建一个核心线程；当正在运行的线程数大于或等于核心线程数时，任务来了先不创建线程而是丢到任务队列中
    maximumPoolSize
    最大线程数,当任务队里满了时，来一个任务才创建一个非核心线程，但不能超过最大线程数
    keepAliveTime + unit
    线程保持空闲时间及单位
    默认情况下，次两参数仅当正在运行的线程数大于核心线程数时才有效，即只针对非核心线程。
    但是，如果allowCoreThreadTimeout被设置成了true,针对核心线程也有效。
    即当任务队列为空时，线程保持多久才会销毁，内部主要是通过阻塞低劣带超时的poll(timeout,unit)实现的
    workQueue
    任务队列
    当正在运行的线程大于或等于核心线程数时，任务来乐是先进入任务队列中的
    这个队列必须是阻塞队列，所以像ConcurrentLinkedQueue就不能作为参数，因为它虽然是并发的安全的队列，但是它不是阻塞队列。
    threadFactory 线程工厂
    默认使用的是Executor工具类中的DefaultThreadFactory类，这个类有个缺点，创建的线程的名称是自动生成的，无法自定义义区分不同的线程池，且他们都是非守护线程
    static class DefaultThreadFactory implements ThreadFactory{
        private static final AtomicInteger poolNumber = new AtomicInteger(1);//池数量
        private final ThreadGroup group;//线程组
        private final AtomicInteger threadNumber = new AtomicInteger();//线程数量
        private final String namePrefix;
        DefaultThreadFactory(){
            SecurityManager s = System.getSecurityManager();        //安全管理器
            group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
            namePrefix = "pool-"+poolNumber.getAndIncrement()+"thread-";
        }
        @Override
        public Thread newThread(Runnable r){
            Thread t = new Thread(group,r,namePrefix+threadNumber.getAndIncrement(),0);
            if(t.siDaemon())
                t.setDaemon(false);
            if(t.getPriority() != Thread.NORM_PRIORITY) //设置优先级为正常
                t.setPriority(Thread.NORM_PRIORITY)
        }
    }

    Handler 拒接策略
    拒接策略表示当任务队列满了且线程数也达到最大了，这时候再加新任务，线程池已经无法承受了，这些新来的任务应该按什么逻辑来处理。
    常用的拒绝策略有丢弃当前任务、求其最老的任务、抛出异常、调用者自己处理等待。
    默认的拒绝策略是抛出异常，即线程池无法承载了，调用者再往里面添加任务会抛出异常。
    默认的拒绝的策略虽然比较简单粗暴，但是相对于任务策略明显要好很多，最起码调用者自己可以捕获这个异常在进行二次处理

