    线程池ThreadPoolExecutor中定义了的生命周期中的状态及相关方法
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING,0));
    private static final int COUNT_BITS = Integer.SIZE - 3//=29
    private static final int CAPACITY = (1 << COUNT_BITS) -1;//=000 11111...

    //runState is stored in the high-order bits runState存储在高位
    private static final int RUNNING = -1 << COUNT_BITS;//111 00000...
    private static final int SHUTDOWN = 0 << COUNT_BITS;//000 00000...
    private static final int STOP = 1 << COUNT_BITS;//001 00000...
    private static final int TIDYING = 2 << COUNT_BITS;//010 00000...
    private static final int TERMINATED = 3 << COUNT_BITS;//011 00000...

    //线程池的状态
    private static int runStateOf(int c){return c & ~CAPACITY;}
    //线程池中工作线程的数量
    private static int workerCountOf(int c){return c & CAPACITY;}
    //计算ctl的值，等于运行状态 加上 线程数量
    private static int ctlOf(int rs,int wc){return rs | wc;}

    以上代码可以得出:
        (1)线程池的状态和工作线程的数量共同保存在控制变量ctl中，类似于AQS中的state变量，不过这里是直接使用的AtomicInteger，这里换成unsafe+volatile也是可以的；
        （2）ctl的高三位保存运行状态，低29为保存工作线程的数量，也就是线程的数量最多只能有(2^29-1)个，也就是上面的CAPACITY;
        (3)线程池的状态一共有五种:RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED;
        (4)RUNNING,表示可接受新任务，且可执行队列中的任务
        (5)SHUTDOWN,表示不接受新任务，但可执行队列中的任务
        (6)STOP，表示不接受新任务，且不再执行队列中的任务，且中断正在执行的任务
        (7)TIDYING，所有任务已经中止，且工作线程数量为0，最后变迁到这个状态的线程将要执行terminated()钩子方法，只会有一个线程执行这个方法；
        (8)TERMINATED，中止状态，已经执行完terminated()钩子方法；
    源码:
        （1）RUNNING
        RUNNING，比较简单，创建线程池的时候就会初始化ctl，而ctl初始化为RUNNING状态，所以线程池的初始状态就为RUNNING状态。
        // 初始状态为RUNNING
        private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
        (2)SHUTDOWN
        执行shutdown()方法时把状态修改为SHUTDOWN，这里肯定会成功，因为advanceRunState()方法中是个自旋，不成功不会退出
        public void shutdown(){
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try{
                checkShutdownAccess();
                //修改状态为SHUTDOWN
                advanceRunState(SHUTDOWN);
                //标记空闲线程为中断状态
                interruptIdleWorkers();
                onShutdown();
            }finally{
                mainLock.unlock();
            }
            tryTerminate();     //尝试终止
        }
        private void advanceRunState(int targetState){
            for(;;){
                int c = ctl.get();
                //如果状态大于SHUTDOWN,或者修改为SHUTDOWN成功了，才会break跳出自旋
                if(runStateAtLeast(c,targetState) || ctl.compareAndSet(c,ctlOf(targetState,workerCountOf(c))))
                    break;
            }
        }
        (stop )